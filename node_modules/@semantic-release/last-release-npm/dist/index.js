'use strict';

var SemanticReleaseError = require('@semantic-release/error');

var npmlog = require('npmlog');
var RegClient = require('npm-registry-client');

module.exports = function (pluginConfig, _ref, cb) {
  var pkg = _ref.pkg;
  var npm = _ref.npm;
  var plugins = _ref.plugins;
  var options = _ref.options;

  npmlog.level = npm.loglevel || 'warn';
  var clientConfig = { log: npmlog };
  // disable retries for tests
  if (pluginConfig && pluginConfig.retry) clientConfig.retry = pluginConfig.retry;
  var client = new RegClient(clientConfig);

  client.get('' + npm.registry + pkg.name.replace('/', '%2F'), {
    auth: npm.auth
  }, function (err, data) {
    if (err && (err.statusCode === 404 || /not found/i.test(err.message))) {
      return cb(null, {});
    }

    if (err) return cb(err);

    var version = data['dist-tags'][npm.tag];

    if (!version && options && options.fallbackTags && options.fallbackTags[npm.tag] && data['dist-tags'][options.fallbackTags[npm.tag]]) {
      version = data['dist-tags'][options.fallbackTags[npm.tag]];
    }

    if (!version) {
      return cb(new SemanticReleaseError('There is no release with the dist-tag "' + npm.tag + '" yet.\nTag a version manually or define "fallbackTags".', 'ENODISTTAG'));
    }

    cb(null, Object.defineProperties({
      version: version,
      gitHead: data.versions[version].gitHead
    }, {
      tag: {
        get: function get() {
          npmlog.warn('deprecated', 'tag will be removed with the next major release');
          return npm.tag;
        },
        configurable: true,
        enumerable: true
      }
    }));
  });
};