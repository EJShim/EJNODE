"use strict";
// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.
exports.Matrix = require('./matrix');
exports.Colon = require('./colon');
exports.colon = require('./colonwrap');
var util = require('./util');
var func_generator = require('./func_generator');
var shape_converter = require('./shape_converter');
var reduction = require('./reduction');
var mul = require('./mul');
var npy = require('./io/npy');
//export import MatrixCL = require('./cl/matrix_cl');
exports.CL = null; // for webcl
exports.end = -1;
var initcl_result = null;
function initcl() {
    if (initcl_result != null) {
        return initcl_result;
    }
    try {
        var dummy = require('../src/cl/handwrittenjs/sushi_cl');
        initcl_result = true;
    }
    catch (ex) {
        console.error(ex);
        initcl_result = false;
    }
    return initcl_result;
}
exports.initcl = initcl;
function devicetype(A) {
    if (A instanceof exports.Matrix) {
        return 'cpu';
    }
    return null;
}
exports.devicetype = devicetype;
function autodestruct(f) {
    exports.Matrix.autodestruct_push();
    var mats_to_save = [];
    try {
        mats_to_save = f();
    }
    finally {
        if (typeof (mats_to_save) === 'object') {
            var mats_list;
            if (mats_to_save instanceof exports.Matrix) {
                // single matrix return
                mats_list = [mats_to_save];
            }
            else if (mats_to_save.length !== undefined) {
                //array-like
                mats_list = mats_to_save.filter(function (v) { return (v instanceof exports.Matrix); });
            }
            else {
                //dictionary
                mats_list = [];
                for (var k in mats_to_save) {
                    if (mats_to_save[k] instanceof exports.Matrix) {
                        mats_list.push(mats_to_save[k]);
                    }
                }
            }
            var stack_top = exports.Matrix._autodestruct_stack_top;
            var stack_second_top = exports.Matrix._autodestruct_stack[exports.Matrix._autodestruct_stack.length - 2];
            for (var i = 0; i < mats_list.length; i++) {
                var mat = mats_list[i];
                var delete_idx = stack_top.indexOf(mat);
                if (delete_idx >= 0) {
                    stack_top.splice(delete_idx, 1);
                    if (stack_second_top) {
                        stack_second_top.push(mat); //maybe destructed in nested autodestruct
                    }
                }
            }
        }
        exports.Matrix.autodestruct_pop();
    }
    return mats_to_save;
}
exports.autodestruct = autodestruct;
exports.typedarray2mat = exports.Matrix.typedarray2mat;
function zeros() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var format = util.calc_zeros_size(args);
    return new exports.Matrix(format.size, format.klass);
}
exports.zeros = zeros;
function ones() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var mat = zeros.apply(void 0, args);
    mat._data.fill(1);
    return mat;
}
exports.ones = ones;
function rand() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var mat = zeros.apply(void 0, args);
    var data = mat._data;
    for (var i = 0, length = data.length; i < length; i++) {
        data[i] = Math.random();
    }
    return mat;
}
exports.rand = rand;
function randi(imax) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    //first argument: imax or [imin, imax]
    var _imin = 1, _imax = 1;
    if (imax.length != null) {
        if (imax.length === 2) {
            _imin = imax[0];
            _imax = imax[1];
        }
        else {
            throw new Error('Invalid imax');
        }
    }
    else {
        _imax = imax;
    }
    var mat = zeros.apply(void 0, args);
    var data = mat._data;
    for (var i = 0, length = data.length; i < length; i++) {
        data[i] = Math.floor(Math.random() * (_imax - _imin + 1)) + _imin;
    }
    return mat;
}
exports.randi = randi;
function randn() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var mat = zeros.apply(void 0, args);
    var data = mat._data;
    for (var i = 0, length = data.length; i < length; i++) {
        var alpha = Math.random();
        var beta = Math.random();
        data[i] = Math.sqrt(-2 * Math.log(alpha)) * Math.sin(2 * Math.PI * beta);
    }
    return mat;
}
exports.randn = randn;
function eye() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var mat = zeros.apply(void 0, args);
    var min_dim = Math.min(mat._size[0], mat._size[1]);
    for (var i = 1; i <= min_dim; i++) {
        mat.set(i, i, 1);
    }
    return mat;
}
exports.eye = eye;
function size(X, dim) {
    if (dim === void 0) {
        // return as row vector
        return jsa2mat([X._size], false, 'int32'); //int32 to represent value > 8M accurately
    }
    else {
        if (dim <= 0 || !exports.Matrix._isinteger(dim)) {
            throw new Error('Invalid dimension');
        }
        return X._size[dim - 1] || 1;
    }
}
exports.size = size;
function sizejsa(X) {
    return X._size;
}
exports.sizejsa = sizejsa;
function jsa2mat(A, one_d_column, klass) {
    return exports.Matrix.jsa2mat(A, one_d_column, klass);
}
exports.jsa2mat = jsa2mat;
function mat2jsa(A, one_d_flatten) {
    if (one_d_flatten === void 0) { one_d_flatten = false; }
    return A.mat2jsa(one_d_flatten);
}
exports.mat2jsa = mat2jsa;
function length(X) {
    return Math.max.apply(null, X._size);
}
exports.length = length;
function ndims(X) {
    return X._ndims;
}
exports.ndims = ndims;
function numel(X) {
    return X._numel;
}
exports.numel = numel;
function iscolumn(A) {
    return A._ndims == 2 && A._size[1] == 1;
}
exports.iscolumn = iscolumn;
function isrow(A) {
    return A._ndims == 2 && A._size[0] == 1;
}
exports.isrow = isrow;
function isvector(A) {
    return A._ndims == 2 && (A._size[0] == 1 || A._size[1] == 1);
}
exports.isvector = isvector;
function isempty(A) {
    return A._numel == 0;
}
exports.isempty = isempty;
function ismatrix(A) {
    return A._ndims == 2;
}
exports.ismatrix = ismatrix;
function isscalar(A) {
    // currently, number is not supported
    return A._numel == 1;
}
exports.isscalar = isscalar;
function klass(object) {
    return object._klass;
}
exports.klass = klass;
function gpuArray(A) {
    //overriden by sushi_cl
    return util.as_mat(A).copy();
}
exports.gpuArray = gpuArray;
function gather(A) {
    //overriden by sushi_cl
    return A.copy();
}
exports.gather = gather;
function jsaequal(a, b) {
    if (a.length != b.length) {
        return false;
    }
    for (var i = 0; i < a.length; i++) {
        if (a[i] != b[i]) {
            return false;
        }
    }
    return true;
}
// If input is 1x1 matrix, returns number
function _singlemat2number(A) {
    if ((A instanceof exports.Matrix) && isscalar(A)) {
        return A.get_scalar([1]);
    }
    return A;
}
//equality http://jp.mathworks.com/help/matlab/relational-operators.html
/**
 * Compares elements of two matrices. One of the input can be scalar number.
 *
 * @param A Input matrix.
 * @param B Input matrix.
 * @return logical matrix. 1 if A(i) == B(i).
 */
exports.eq = function (A, B) {
    throw new Error();
};
exports.eq = func_generator.make_compare_func_all('Number(%a == %b)');
/**
 * Compares elements of two matrices. One of the input can be scalar number.
 *
 * @param A Input matrix.
 * @param B Input matrix.
 * @return logical matrix. 1 if A(i) >= B(i).
 */
exports.ge = function (A, B) {
    throw new Error();
};
exports.ge = func_generator.make_compare_func_all('Number(%a >= %b)');
/**
 * Compares elements of two matrices. One of the input can be scalar number.
 *
 * @param A Input matrix.
 * @param B Input matrix.
 * @return logical matrix. 1 if A(i) > B(i).
 */
exports.gt = function (A, B) {
    throw new Error();
};
exports.gt = func_generator.make_compare_func_all('Number(%a > %b)');
/**
 * Compares elements of two matrices. One of the input can be scalar number.
 *
 * @param A Input matrix.
 * @param B Input matrix.
 * @return logical matrix. 1 if A(i) <= B(i).
 */
exports.le = function (A, B) {
    throw new Error();
};
exports.le = func_generator.make_compare_func_all('Number(%a <= %b)');
/**
 * Compares elements of two matrices. One of the input can be scalar number.
 *
 * @param A Input matrix.
 * @param B Input matrix.
 * @return logical matrix. 1 if A(i) < B(i).
 */
exports.lt = function (A, B) {
    throw new Error();
};
exports.lt = func_generator.make_compare_func_all('Number(%a < %b)');
/**
 * Compares elements of two matrices. One of the input can be scalar number.
 *
 * @param A Input matrix.
 * @param B Input matrix.
 * @return logical matrix. 1 if A(i) != B(i).
 */
exports.ne = function (A, B) {
    throw new Error();
};
exports.ne = func_generator.make_compare_func_all('Number(%a != %b)');
/**
 * Checks if all matrices are equal. Assumes NaN is not equal to NaN.
 *
 * @param As Input matrices.
 * @return true if all matrices are the same regarding both size and value of elements.
 */
exports.isequal = function () {
    var As = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        As[_i - 0] = arguments[_i];
    }
    throw new Error();
};
exports.isequal = func_generator.isequal;
/**
 * Checks if all matrices are equal. Assumes NaN is equal to NaN.
 *
 * @param As Input matrices.
 * @return true if all matrices are the same regarding both size and value of elements.
 */
exports.isequaln = function () {
    var As = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        As[_i - 0] = arguments[_i];
    }
    throw new Error();
};
exports.isequaln = func_generator.isequaln;
/**
 * Compares if elements of two matrices are close. One of the input can be scalar number.
 *
 * @param A Input matrix.
 * @param B Input matrix.
 * @return logical matrix. 1 if abs(A(i) - B(i)) <= atol + rtol * abs(B(i)).
 */
exports.isclose = function (A, B, rtol, atol, equal_nan) {
    if (rtol === void 0) { rtol = 1e-5; }
    if (atol === void 0) { atol = 1e-8; }
    if (equal_nan === void 0) { equal_nan = false; }
    throw new Error();
};
exports.isclose = func_generator.isclose;
/**
 * Compares if all the elements of two matrices are close. One of the input can be scalar number. See also [[isclose]]
 *
 * @param A Input matrix.
 * @param B Input matrix.
 * @return true if all elements of isclose(A, B) are 1.
 */
exports.allclose = function (A, B, rtol, atol, equal_nan) {
    throw new Error();
};
exports.allclose = func_generator.allclose;
exports.plus = func_generator.make_binary_arith_func_all('%a + %b');
exports.minus = func_generator.make_binary_arith_func_all('%a - %b');
exports.times = func_generator.make_binary_arith_func_all('%a * %b');
exports.rdivide = func_generator.make_binary_arith_func_all('%a / %b');
exports.ldivide = func_generator.make_binary_arith_func_all('%b / %a');
exports.power = func_generator.make_binary_arith_func_all('Math.pow(%a,%b)');
exports.floor = func_generator.make_unary_arith_func_all('Math.floor(%a)');
exports.fix = func_generator.make_unary_arith_func_all('(%a > 0 ? Math.floor(%a) : Math.ceil(%a))');
exports.ceil = func_generator.make_unary_arith_func_all('Math.ceil(%a)');
exports.uplus = func_generator.make_unary_arith_func_all('+%a');
exports.uminus = func_generator.make_unary_arith_func_all('-%a');
exports.exp = func_generator.make_unary_arith_func_all('Math.exp(%a)');
exports.log = func_generator.make_unary_arith_func_all('Math.log(%a)');
exports.max = reduction.max;
exports.min = reduction.min;
exports.argmax = reduction.argmax;
exports.argmin = reduction.argmin;
exports.sum = reduction.sum;
exports.mean = reduction.mean;
exports.prod = reduction.prod;
exports.std = reduction.std;
exports.variance = reduction.variance;
exports.mtimes = mul.mtimes;
function reshape(A) {
    var sz = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sz[_i - 1] = arguments[_i];
    }
    var dst = A.copy();
    try {
        dst.reshape_inplace.apply(dst, sz);
        return dst;
    }
    catch (error) {
        dst.destruct();
        throw error;
    }
}
exports.reshape = reshape;
function squeeze(A) {
    var dst = A.copy();
    dst.squeeze_inplace();
    return dst;
}
exports.squeeze = squeeze;
exports.transpose = shape_converter.transpose;
exports.t = exports.transpose; //alias
exports.repmat = shape_converter.repmat;
exports.cat = shape_converter.cat;
exports.horzcat = shape_converter.horzcat;
exports.vertcat = shape_converter.vertcat;
exports.permute = shape_converter.permute;
exports.ipermute = shape_converter.ipermute;
exports.npyread = npy.npyread;
exports.npysave = npy.npysave;
//indexing
//TODO:test
function sub2ind(matrixSize) {
    var dimSub = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        dimSub[_i - 1] = arguments[_i];
    }
    //note: 'end' cannot be used in matlab sub2ind; only positive index is valid
    var msizejsa;
    if (matrixSize instanceof exports.Matrix) {
        if (!isrow(matrixSize) || matrixSize._numel < 2) {
            throw new Error('matrixSize must be row vector');
        }
        msizejsa = matrixSize.mat2jsa(true);
    }
    else {
        msizejsa = matrixSize;
    }
    var stride = 1;
    var idx = 1;
    for (var i = 0; i < msizejsa.length; i++) {
        idx += ((dimSub[i] || 1) - 1) * stride;
        stride *= msizejsa[i];
    }
    return idx;
}
exports.sub2ind = sub2ind;
function colonvec(start, stop_step, stop, klass) {
    if (klass === void 0) { klass = 'single'; }
    // make row vector by i:j:k
    var step;
    if (stop == null) {
        stop = stop_step;
        step = 1;
    }
    else {
        step = stop_step;
    }
    var n_item = Math.max(Math.floor((stop - start) / step) + 1, 0);
    var vec = new exports.Matrix([1, n_item], klass);
    var vec_data = vec._data;
    for (var i = 0; i < n_item; i++) {
        vec_data[i] = start + step * i;
    }
    return vec;
}
exports.colonvec = colonvec;
//# sourceMappingURL=sushi.js.map