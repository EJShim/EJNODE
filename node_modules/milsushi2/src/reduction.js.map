{"version":3,"file":"reduction.js","sourceRoot":"","sources":["reduction.ts"],"names":[],"mappings":"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","sourcesContent":["// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\nimport Matrix = require('./matrix');\nimport util = require('./util');\nimport func_generator = require('./func_generator');\n\nexport type MatrixOrNumber = util.MatrixOrNumber;\n\nfunction max_along_axis_old(A: Matrix, dim?: number): Matrix {\n  if (dim == null) {\n    //select first non-1 axis\n    dim = A._numel;\n    for (var i = 0; i < A._size.length; i++) {\n      var dimsize = A._size[i];\n      if (dimsize !== 1) {\n        dim = i + 1;\n        break;\n      }\n    }\n  }\n\n  if (dim > A._ndims) {\n    //max along axis with size 1\n    return A.copy();\n  }\n\n  var dstsize = A._size.slice();\n  if (dstsize[dim - 1] !== 0) {\n    //size 0 dimension is preserved\n    dstsize[dim - 1] = 1;\n  }\n\n  if ((A._numel === 0) || (A._size[dim - 1] === 1)) {\n    //only change shape\n    var dst_onlyreshape = A.copy();\n    dst_onlyreshape.reshape_inplace(dstsize);\n    return dst_onlyreshape;\n  }\n\n  //reduction actually needed\n  var dst = new Matrix(dstsize, A._klass);\n  var input_strides = A._strides;\n  var output_strides = dst._strides.slice();\n  while (output_strides.length <= input_strides.length) {\n    output_strides.push(dst._numel);\n  }\n\n  var reduction_step = input_strides[dim - 1];\n  var reduction_count = A._size[dim - 1];\n  var a_data = A._data;\n  var dst_data = dst._data;\n  var dims = A._ndims;\n  for (var dst_idx = 0, dst_numel = dst._numel; dst_idx < dst_numel; dst_idx++) {\n    var src_idx = 0;\n    for (var d = 0; d < dims; d++) {\n      src_idx += Math.floor(dst_idx % output_strides[d + 1] / output_strides[d]) * input_strides[d];\n    }\n\n    var val = a_data[src_idx];\n    var curret = val;\n    for (var red = 1; red < reduction_count; red++) {\n      src_idx += reduction_step;\n      val = a_data[src_idx];\n      if (val > curret) {\n        curret = val;\n      }\n    }\n\n    dst_data[dst_idx] = curret;\n  }\n\n  return dst;\n}\n\nfunction _argmax_ones_like(A: Matrix): { M: Matrix, I: Matrix } {\n  var amax = new Matrix(A._size, 'int32');\n  amax._data.fill(1);\n  return { M: A, I: amax };\n}\n\nfunction make_reduction_along_axis(var_decl: string, var_update: string, result_assign: string, out_argmax: boolean) {\n  var f: any;\n  eval([\n    \"f = function(A, dim) {\",\n    \"    if (dim == null) {\",\n    \"        //select first non-1 axis\",\n    \"        dim = A._numel;\",\n    \"        for (var i = 0; i < A._size.length; i++) {\",\n    \"            var dimsize = A._size[i];\",\n    \"            if (dimsize !== 1) {\",\n    \"                dim = i + 1;\",\n    \"                break;\",\n    \"            }\",\n    \"        }\",\n    \"    }\",\n    \"    if (dim > A._ndims) {\",\n    \"        //max along axis with size 1\",\n    out_argmax ? \"return _argmax_ones_like(A.copy());\" : \"return A.copy();\",\n    \"    }\",\n    \"    var dstsize = A._size.slice();\",\n    \"    if (dstsize[dim - 1] !== 0) {\",\n    \"        //size 0 dimension is preserved\",\n    \"        dstsize[dim - 1] = 1;\",\n    \"    }\",\n    \"    if (A._numel === 0) {\",\n    \"        //only change shape\",\n    \"        var dst_onlyreshape = A.copy();\",\n    \"        dst_onlyreshape.reshape_inplace(dstsize);\",\n    out_argmax ? \"return _argmax_ones_like(dst_onlyreshape);\" : \"return dst_onlyreshape;\",\n    \"    }\",\n    \"    //reduction actually needed\",\n    \"    var dst = new Matrix(dstsize, A._klass);\",\n    out_argmax ? \"var amax = new Matrix(dstsize, 'int32'); var amax_data = amax._data;\" : \"\",\n    \"    var input_strides = A._strides;\",\n    \"    var output_strides = dst._strides.slice();\",\n    \"    while (output_strides.length <= input_strides.length) {\",\n    \"        output_strides.push(dst._numel);\",\n    \"    }\",\n    \"    var reduction_step = input_strides[dim - 1];\",\n    \"    var reduction_count = A._size[dim - 1];\",\n    \"    var a_data = A._data;\",\n    \"    var dst_data = dst._data;\",\n    \"    var dims = A._ndims;\",\n    \"    for (var dst_idx = 0, dst_numel = dst._numel; dst_idx < dst_numel; dst_idx++) {\",\n    \"        var src_idx = 0;\",\n    \"        for (var d = 0; d < dims; d++) {\",\n    \"            src_idx += Math.floor(dst_idx % output_strides[d + 1] / output_strides[d]) * input_strides[d];\",\n    \"        }\",\n    \"        var val = a_data[src_idx];\",\n    //\"        var curret = val;\",\n    var_decl,\n    \"        for (var red = 1; red < reduction_count; red++) {\",\n    \"            src_idx += reduction_step;\",\n    \"            val = a_data[src_idx];\",\n    //\"            if (val > curret) {\",\n    //\"                curret = val;\",\n    //\"            }\",\n    var_update,\n    \"        }\",\n    //\"        dst_data[dst_idx] = curret;\",\n    result_assign,\n    \"    }\",\n    out_argmax ? \"return {M:dst,I:amax};\" : \"return dst;\",\n    \"}\",].join('\\n'));\n  return f;\n}\n\nfunction make_reduction_along_axis_stat(var_decl: string, var_update: string, result_assign: string) {\n  var f: any;\n  eval([\n    \"f = function(A, dim) {\",\n    \"    if (dim == null) {\",\n    \"        //select first non-1 axis\",\n    \"        dim = A._numel;\",\n    \"        for (var i = 0; i < A._size.length; i++) {\",\n    \"            var dimsize = A._size[i];\",\n    \"            if (dimsize !== 1) {\",\n    \"                dim = i + 1;\",\n    \"                break;\",\n    \"            }\",\n    \"        }\",\n    \"    }\",\n    \"    if (dim > A._ndims) {\",\n    \"        //max along axis with size 1\",\n    \"    }\",\n    \"    var dstsize = A._size.slice();\",\n    \"    if (dstsize[dim - 1] !== 0) {\",\n    \"        //size 0 dimension is preserved\",\n    \"        dstsize[dim - 1] = 1;\",\n    \"    }\",\n    \"    if (A._numel === 0) {\",\n    \"        //only change shape\",\n    \"        var dst_onlyreshape = A.copy();\",\n    \"        dst_onlyreshape.reshape_inplace(dstsize);\",\n    \"        return dst_onlyreshape;\",\n    \"    }\",\n    \"    //reduction actually needed\",\n    \"    var dst = new Matrix(dstsize, 'single');\",\n    \"    var input_strides = A._strides;\",\n    \"    var output_strides = dst._strides.slice();\",\n    \"    while (output_strides.length <= input_strides.length) {\",\n    \"        output_strides.push(dst._numel);\",\n    \"    }\",\n    \"    var reduction_step = input_strides[dim - 1];\",\n    \"    var reduction_count = A._size[dim - 1];\",\n    \"    var a_data = A._data;\",\n    \"    var dst_data = dst._data;\",\n    \"    var dims = A._ndims;\",\n    \"    for (var dst_idx = 0, dst_numel = dst._numel; dst_idx < dst_numel; dst_idx++) {\",\n    \"        var src_idx = 0;\",\n    \"        for (var d = 0; d < dims; d++) {\",\n    \"            src_idx += Math.floor(dst_idx % output_strides[d + 1] / output_strides[d]) * input_strides[d];\",\n    \"        }\",\n    \"        var val = a_data[src_idx];\",\n    //\"        var curret = val;\",\n    var_decl,\n    \"        for (var red = 1; red < reduction_count; red++) {\",\n    \"            src_idx += reduction_step;\",\n    \"            val = a_data[src_idx];\",\n    //\"            if (val > curret) {\",\n    //\"                curret = val;\",\n    //\"            }\",\n    var_update,\n    \"        }\",\n    //\"        dst_data[dst_idx] = curret;\",\n    result_assign,\n    \"    }\",\n    \"return dst;\",\n    \"}\",].join('\\n'));\n  return f;\n}\n\nvar max_along_axis = make_reduction_along_axis('var curret = val;',\n  'if(val>curret){curret=val;}',\n  'dst_data[dst_idx]=curret;', false);\nvar max_elementwise = func_generator.make_binary_arith_func_all('Math.max(%a,%b)');\n\nvar min_along_axis = make_reduction_along_axis('var curret = val;',\n  'if(val<curret){curret=val;}',\n  'dst_data[dst_idx]=curret;', false);\nvar min_elementwise = func_generator.make_binary_arith_func_all('Math.min(%a,%b)');\n\nexport function max(A: MatrixOrNumber, B?: MatrixOrNumber, dim?: number): Matrix {\n  if (B == null) {\n    //max along axis\n    return max_along_axis(util.as_mat(A), dim);\n  } else {\n    //elementwise max\n    return max_elementwise(A, B);\n  }\n}\n\n\nexport function min(A: MatrixOrNumber, B?: MatrixOrNumber, dim?: number): Matrix {\n  if (B == null) {\n    return min_along_axis(util.as_mat(A), dim);\n  } else {\n    return min_elementwise(A, B);\n  }\n}\n\n\nvar argmax_along_axis = make_reduction_along_axis('var curret = val, curamax = 0;',\n  'if(val>curret){curret=val;curamax=red;}',\n  'dst_data[dst_idx]=curret; amax_data[dst_idx]=curamax+1;', true);\nexport function argmax(A: MatrixOrNumber, dummy?: any, dim?: number): { M: Matrix, I: Matrix } {\n  return argmax_along_axis(util.as_mat(A), dim);\n}\n\nvar argmin_along_axis = make_reduction_along_axis('var curret = val, curamax = 0;',\n  'if(val<curret){curret=val;curamax=red;}',\n  'dst_data[dst_idx]=curret; amax_data[dst_idx]=curamax+1;', true);\nexport function argmin(A: MatrixOrNumber, dummy?: any, dim?: number): { M: Matrix, I: Matrix } {\n  return argmin_along_axis(util.as_mat(A), dim);\n}\n\nfunction sum_mean(A: Matrix, args: any[], f: (A: Matrix, dim: number) => Matrix): Matrix {\n  var dim = undefined;\n  var outtype = undefined;\n  while (args.length > 0) {\n    var arg = args.pop();\n    if (typeof (arg) === 'string') {\n      if (arg != 'native') {\n        throw new Error('Outtype other than native is currently not supported');\n      }\n    } else if (typeof (arg) === 'number') {\n      dim = arg;\n    } else {\n      throw new Error('Unknown argument ' + arg);\n    }\n  }\n  return f(A, dim);\n}\n\nvar sum_along_axis = make_reduction_along_axis_stat('var curret = val;',\n  'curret += val;', 'dst_data[dst_idx] = curret;');\nexport function sum(A: Matrix): Matrix;\nexport function sum(A: Matrix, dim: number, outtype?: string): Matrix;\nexport function sum(A: Matrix, outtype?: string): Matrix;\nexport function sum(A: Matrix, ...args: any[]): Matrix {\n  return sum_mean(A, args, sum_along_axis);\n}\n\nvar mean_along_axis = make_reduction_along_axis_stat('var curret = val;',\n  'curret += val;', 'dst_data[dst_idx] = curret / reduction_count;');\nexport function mean(A: Matrix): Matrix;\nexport function mean(A: Matrix, dim: number, outtype?: string): Matrix;\nexport function mean(A: Matrix, outtype?: string): Matrix;\nexport function mean(A: Matrix, ...args: any[]): Matrix {\n  return sum_mean(A, args, mean_along_axis);\n}\n\nvar prod_along_axis = make_reduction_along_axis_stat('var curret = val;',\n  'curret *= val;', 'dst_data[dst_idx] = curret;');\nexport function prod(A: Matrix): Matrix;\nexport function prod(A: Matrix, dim: number, outtype?: string): Matrix;\nexport function prod(A: Matrix, outtype?: string): Matrix;\nexport function prod(A: Matrix, ...args: any[]): Matrix {\n  return sum_mean(A, args, prod_along_axis);\n}\n\n//w=0: normalize by N-1\nvar variance_along_axis_w0 = make_reduction_along_axis_stat('var normalsum = val; var sqsum = val * val;',\n  'normalsum += val; sqsum += val * val;', 'dst_data[dst_idx] = (sqsum - normalsum * normalsum / reduction_count) / Math.max(reduction_count - 1, 1);');\n//w=1: normalize by N\nvar variance_along_axis_w1 = make_reduction_along_axis_stat('var normalsum = val; var sqsum = val * val;',\n  'normalsum += val; sqsum += val * val;', 'dst_data[dst_idx] = (sqsum - normalsum * normalsum / reduction_count) / reduction_count;');\nexport function variance(A: Matrix, w: number = 0, dim?: number): Matrix {\n  if (w == 0) {\n    return variance_along_axis_w0(A, dim);\n  } else if (w == 1) {\n    return variance_along_axis_w1(A, dim);\n  } else {\n    throw new Error('w must be 0 or 1');\n  }\n}\n\n//w=0: normalize by N-1\nvar std_along_axis_w0 = make_reduction_along_axis_stat('var normalsum = val; var sqsum = val * val;',\n  'normalsum += val; sqsum += val * val;', 'dst_data[dst_idx] = Math.sqrt((sqsum - normalsum * normalsum / reduction_count) / Math.max(reduction_count - 1, 1));');\n//w=1: normalize by N\nvar std_along_axis_w1 = make_reduction_along_axis_stat('var normalsum = val; var sqsum = val * val;',\n  'normalsum += val; sqsum += val * val;', 'dst_data[dst_idx] = Math.sqrt((sqsum - normalsum * normalsum / reduction_count) / reduction_count);');\nexport function std(A: Matrix, w: number = 0, dim?: number): Matrix {\n  if (w == 0) {\n    return std_along_axis_w0(A, dim);\n  } else if (w == 1) {\n    return std_along_axis_w1(A, dim);\n  } else {\n    throw new Error('w must be 0 or 1');\n  }\n}\n"]}