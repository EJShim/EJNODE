{"version":3,"file":"matrix_cl.js","sourceRoot":"","sources":["matrix_cl.ts"],"names":[],"mappings":";;;;;;AAAA,mFAAmF;AACnF,IAAO,MAAM,WAAW,WAAW,CAAC,CAAC;AACrC,IAAO,KAAK,WAAW,UAAU,CAAC,CAAC;AAEnC,IAAO,GAAG,WAAW,wBAAwB,CAAC,CAAC;AAC/C,IAAI,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC;AAEtB,IAAI,MAAM,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC;AACjF,IAAI,UAAU,GAAG,EAAE,MAAM,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;AAIzH;IAAuB,4BAAM;IAG3B,kBAAY,IAAc,EAAE,KAAc;QACxC,kBAAM,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;QACzB,IAAI,WAAW,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC;QAClE,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;YACrB,iFAAiF;YACjF,WAAW,GAAG,CAAC,CAAC;QAClB,CAAC;QACD,IAAI,CAAC,SAAS,GAAG,GAAG,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;IACjD,CAAC;IAED,yBAAM,GAAN;QACE,IAAI,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QACjD,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACxB,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IAEO,sCAAmB,GAA3B;QACE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;YACpB,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;QACtD,CAAC;IACH,CAAC;IAED,wBAAK,GAAL,UAAM,eAAoB,EAAE,gBAAyB;QACnD,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,EAAE,CAAC,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC/B,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,SAAS,EAAE,eAAe,EAAE,gBAAgB,CAAC,CAAC;QACrE,CAAC;IACH,CAAC;IAED,uBAAI,GAAJ,UAAK,eAAoB,EAAE,gBAAyB;QAClD,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,EAAE,CAAC,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC/B,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,EAAE,eAAe,EAAE,gBAAgB,CAAC,CAAC;QACpE,CAAC;IACH,CAAC;IAEM,uBAAc,GAArB,UAAsB,CAAS;QAC7B,EAAE,CAAC,CAAC,CAAC,YAAY,QAAQ,CAAC,CAAC,CAAC;YAC1B,MAAM,CAAW,CAAC,CAAC,IAAI,EAAE,CAAC;QAC5B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,KAAK,GAAG,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC;YAC5C,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;YAC1B,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;IACH,CAAC;IAEM,wBAAe,GAAtB,UAAuB,eAA0C,EAAE,KAAa;QAC9E,IAAI,GAAG,GAAG,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE,eAAe,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC,CAAC;QAC3D,GAAG,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;QAC3B,MAAM,CAAC,GAAG,CAAC;IACb,CAAC;IAED,2BAAQ,GAAR;QACE,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;YACnB,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAClC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACxB,CAAC;IACH,CAAC;IAED,0BAAO,GAAP,UAAQ,KAAa;QACnB,IAAI,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACrC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,GAAG,CAAC,CAAC,CAAC;YACvB,MAAM,CAAC,WAAW,GAAG,SAAS,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAC9E,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,WAAW,GAAG,SAAS,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QACrD,CAAC;IACH,CAAC;IAED,2BAAQ,GAAR;QACE,gCAAgC;QAChC,IAAI,WAAW,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACnD,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACvB,MAAM,CAAC,WAAW,CAAC;IACrB,CAAC;IAED,6BAAU,GAAV,UAAW,UAAsB,EAAE,MAAe;QAAvC,0BAAsB,GAAtB,cAAsB;QAC/B,6BAA6B;QAC7B,kCAAkC;QAClC,EAAE,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,CAAC,CAAC;YACnB,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC;QACpC,CAAC;QACD,IAAI,WAAW,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QAC9C,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC;QACvE,MAAM,CAAC,WAAW,CAAC;IACrB,CAAC;IAED,8BAAW,GAAX,UAAY,UAAsB,EAAE,MAAe,EAAE,GAA+B;QAAxE,0BAAsB,GAAtB,cAAsB;QAChC,EAAE,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,CAAC,CAAC;YACnB,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC;QACpC,CAAC;QACD,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACT,GAAG,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QACpC,CAAC;QAED,IAAI,UAAU,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;QACzE,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC;QAEtE,MAAM,CAAC,GAAG,CAAC;IACb,CAAC;IAED,0BAAO,GAAP,UAAQ,GAA8B,EAAE,UAAsB;QAAtB,0BAAsB,GAAtB,cAAsB;QAC5D,0BAA0B;QAC1B,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC;IAClE,CAAC;IAEM,qBAAY,GAAnB,UAAoB,SAAiB,EAAE,SAAiB;QACtD,IAAI,QAAgB,CAAC;QACrB,EAAE,CAAC,CAAC,SAAS,IAAI,SAAS,CAAC,CAAC,CAAC;YAC3B,QAAQ,GAAG,KAAK,CAAC;QACnB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,SAAS,IAAI,SAAS,CAAC,CAAC,CAAC;YAClC,QAAQ,GAAG,GAAG,GAAG,SAAS,GAAG,MAAM,CAAC;QACtC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,QAAQ,GAAG,oBAAoB,CAAC;QAClC,CAAC;QACD,MAAM,CAAC,QAAQ,CAAC;IAClB,CAAC;IAED,uBAAI,GAAJ,UAAK,KAAc;QACjB,IAAI,KAAK,GAAG,IAAI,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC;QAC3D,IAAI,WAAW,GAAG,OAAO,GAAG,KAAK,CAAC,MAAM,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;QAC7D,IAAI,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;QAChD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACZ,MAAM,GAAG,GAAG,CAAC,YAAY,CAAC;gBACxB,mBAAmB,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC;gBAC1C,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACzC,uBAAuB,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC;gBAC1E,0FAA0F;gBAC1F,8BAA8B;gBAC9B,gCAAgC;gBAChC,+BAA+B;gBAC/B,GAAG;aACJ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACd,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC;QAC9C,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACpB,GAAG,CAAC,aAAa,CAAC,MAAM,EAAE;gBACxB,EAAE,MAAM,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,EAAE,KAAK,EAAE;gBAC9C,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,EAAE,IAAI,EAAE;gBAC5C,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE;aAC9C,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QAClB,CAAC;QACD,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;IAED,wBAAK,GAAL,UAAM,GAAW;QACf,IAAI,WAAW,GAAG,OAAO,GAAG,IAAI,CAAC,MAAM,CAAC;QACxC,IAAI,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;QAChD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACZ,MAAM,GAAG,GAAG,CAAC,YAAY,CAAC;gBACxB,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACzC,gFAAgF;gBAChF,8BAA8B;gBAC9B,gCAAgC;gBAChC,iBAAiB;gBACjB,GAAG;aACJ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACd,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC;QAC9C,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACpB,GAAG,CAAC,aAAa,CAAC,MAAM,EAAE;gBACxB,EAAE,MAAM,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,EAAE,IAAI,EAAE;gBAC7C,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE;gBAC7C,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;aAC9C,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QAClB,CAAC;IACH,CAAC;IAKD,sBAAG,GAAH;QAAI,cAAc;aAAd,WAAc,CAAd,sBAAc,CAAd,IAAc;YAAd,6BAAc;;QAChB,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;YACrB,aAAa;YACb,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9B,CAAC;QACD,IAAI,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,UAAC,CAAC,IAAK,OAAA,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAvB,CAAuB,CAAC,CAAC;QAC5D,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YACf,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAC/B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAClC,CAAC;IACH,CAAC;IAED,6BAAU,GAAV,UAAW,IAAc;QACvB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC5B,IAAI,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QACzC,IAAI,eAAe,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAA,qBAAqB;QAClE,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC;QACzE,MAAM,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;IAC5B,CAAC;IAEc,6BAAoB,GAAnC,UAAoC,GAA8B,EAAE,QAAgB;QAClF,kCAAkC;QAClC,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC;YAC9B,IAAI,YAAY,GAAW,GAAG,CAAC;YAC/B,EAAE,CAAC,CAAC,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC;gBACrB,YAAY,IAAI,QAAQ,GAAG,CAAC,CAAC;YAC/B,CAAC;YACD,EAAE,CAAC,CAAC,YAAY,IAAI,CAAC,IAAI,YAAY,GAAG,QAAQ,CAAC,CAAC,CAAC;gBACjD,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;YAChD,CAAC;YACD,MAAM,CAAC;gBACL,UAAU,EAAE,EAAE,KAAK,EAAE,YAAY,EAAE,IAAI,EAAE,UAAU,CAAC,KAAK,EAAE;gBAC3D,WAAW,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;gBAC5B,QAAQ,EAAE,KAAK;aAChB,CAAC;QACJ,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,YAAY,KAAK,CAAC,CAAC,CAAC;YAChC,IAAI,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC;YACtB,IAAI,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;YACpB,IAAI,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;YACpB,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;gBACZ,KAAK,GAAG,CAAC,CAAC;gBACV,IAAI,GAAG,QAAQ,CAAC;gBAChB,IAAI,GAAG,CAAC,CAAC;YACX,CAAC;YACD,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;gBACd,KAAK,IAAI,QAAQ,GAAG,CAAC,CAAC;YACxB,CAAC;YACD,EAAE,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;gBACb,IAAI,IAAI,QAAQ,GAAG,CAAC,CAAC;YACvB,CAAC;YACD,IAAI,MAAM,GAAW,CAAC,CAAC;YACvB,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC;gBAC/D,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;gBAC/C,0BAA0B;gBAC1B,IAAI,WAAW,GAAG,KAAK,GAAG,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBAC9C,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,IAAI,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,WAAW,IAAI,CAAC,IAAI,WAAW,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;oBACrF,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;gBAChD,CAAC;YACH,CAAC;YACD,MAAM,CAAC;gBACL,UAAU,EAAE,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC,EAAE,IAAI,EAAE,UAAU,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE;gBAC5F,WAAW,EAAE,IAAI;gBACjB,MAAM,EAAE,MAAM;gBACd,QAAQ,EAAE,MAAM;aACjB,CAAA;QACH,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,YAAY,MAAM,CAAC,CAAC,CAAC;YACjC,IAAI,WAAW,GAAG,IAAI,CAAC;YACvB,IAAI,OAAiB,CAAC;YACtB,EAAE,CAAC,CAAC,GAAG,YAAY,QAAQ,CAAC,CAAC,CAAC;gBAC5B,OAAO,GAAG,GAAG,CAAC;YAChB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;gBACvC,WAAW,GAAG,OAAO,CAAC;YACxB,CAAC;YACD,0BAA0B;YAE1B,IAAI,WAAW,GAAG,uBAAuB,GAAG,GAAG,CAAC,MAAM,CAAC;YACvD,IAAI,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;YAChD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACZ,IAAI,UAAU,GAAG;oBACf,mBAAmB,GAAG,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC;oBACxC,6GAA6G;oBAC7G,8BAA8B;oBAC9B,oCAAoC;oBACpC,8BAA8B;oBAC9B,oEAAoE;oBACpE,iBAAiB;oBACjB,KAAK;oBACL,GAAG;iBACJ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACb,MAAM,GAAG,GAAG,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;gBACtC,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC;YAC9C,CAAC;YACD,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBACvB,IAAI,eAAe,GAAG,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;gBACpD,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACzB,GAAG,CAAC,aAAa,CAAC,MAAM,EAAE;oBACxB,EAAE,MAAM,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,EAAE,eAAe,EAAE;oBACxD,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,EAAE,OAAO,EAAE;oBAC/C,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE;oBACzC,EAAE,KAAK,EAAE,OAAO,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE;iBACjD,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;gBACnB,EAAE,CAAC,CAAC,eAAe,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACpC,eAAe,CAAC,QAAQ,EAAE,CAAC;oBAC3B,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;wBAChB,WAAW,CAAC,QAAQ,EAAE,CAAC;oBACzB,CAAC;oBACD,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;gBAChD,CAAC;gBACD,eAAe,CAAC,QAAQ,EAAE,CAAC;YAC7B,CAAC;YAED,MAAM,CAAC;gBACL,UAAU,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE;gBAC3D,WAAW,EAAE,WAAW;gBACxB,MAAM,EAAE,OAAO,CAAC,MAAM;gBACtB,QAAQ,EAAE,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,IAAI;aACtD,CAAA;QACH,CAAC;IACH,CAAC;IAED,gCAAa,GAAb,UAAc,IAAiC;QAC7C,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC;QAC5B,IAAI,gBAAgB,GAAa,EAAE,CAAC;QACpC,IAAI,CAAC;YACH,qCAAqC;YACrC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC;gBACnC,IAAI,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBAClB,EAAE,CAAC,CAAC,GAAG,YAAY,MAAM,CAAC,CAAC,CAAC;oBAC1B,EAAE,CAAC,CAAC,GAAG,CAAC,MAAM,IAAI,SAAS,CAAC,CAAC,CAAC;wBAC5B,IAAI,QAAQ,GAAG,GAAG,CAAC,KAAK,EAAE,CAAC;wBAC3B,IAAI,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAA;wBAClB,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBAClC,CAAC;gBACH,CAAC;YACH,CAAC;YAED,IAAI,mBAAmB,GAAa,EAAE,CAAC;YACvC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,SAAS,CAAC,CAAC,CAAC;gBAC7B,aAAa;gBACb,mBAAmB,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;gBAC1C,OAAO,mBAAmB,CAAC,MAAM,GAAG,SAAS,EAAE,CAAC;oBAC9C,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC9B,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,sCAAsC;gBACtC,IAAI,QAAQ,GAAG,CAAC,CAAC;gBACjB,GAAG,CAAC,CAAC,IAAI,KAAG,GAAG,CAAC,EAAE,KAAG,GAAG,SAAS,GAAG,CAAC,EAAE,KAAG,EAAE,EAAE,CAAC;oBAC7C,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAG,CAAC,CAAC,CAAC;oBAC1C,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,KAAG,CAAC,CAAC;gBAC9B,CAAC;gBACD,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,CAAC;YACnD,CAAC;YACD,IAAI,oBAAoB,GAAa,EAAE,CAAC;YACxC,IAAI,UAAU,GAAG,CAAC,CAAC;YACnB,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;gBACzC,oBAAoB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBACtC,UAAU,IAAI,mBAAmB,CAAC,GAAG,CAAC,CAAC;YACzC,CAAC;YAED,IAAI,WAAW,GAAG,EAAE,CAAC;YACrB,IAAI,iBAAiB,GAAG,EAAE,CAAC;YAC3B,IAAI,SAAS,GAAG,EAAE,CAAC;YACnB,IAAI,UAAU,GAAG,EAAE,CAAC,CAAA,6DAA6D;YACjF,IAAI,cAAc,GAAG,CAAC,CAAC;YACvB,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;gBACzC,IAAI,eAAe,GAAG,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC;gBACzF,EAAE,CAAC,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC,CAAC;oBAChC,gBAAgB,CAAC,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;gBACrD,CAAC;gBACD,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC;gBAC7C,iBAAiB,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;gBACjD,SAAS,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;gBACvC,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;gBAChC,cAAc,IAAI,eAAe,CAAC,MAAM,CAAC;YAC3C,CAAC;YACD,IAAI,SAAS,GAAG,cAAc,CAAC;YAE/B,IAAI,iBAAiB,GAAG,IAAI,CAAC;YAC7B,EAAE,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,CAAC,CAAC;gBACnB,uBAAuB;gBACvB,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA,6BAA6B;gBAC/C,gEAAgE;gBAChE,sBAAsB;gBACtB,2DAA2D;gBAC3D,iCAAiC;gBACjC,IAAI,aAAa,GAAG,KAAK,CAAC;gBAC1B,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACvB,EAAE,CAAC,CAAC,QAAQ,YAAY,MAAM,CAAC,CAAC,CAAC;oBAC/B,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;wBAC/E,aAAa,GAAG,IAAI,CAAC;oBACvB,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,YAAY,KAAK,CAAC,CAAC,CAAC;oBACrC,aAAa,GAAG,IAAI,CAAC;gBACvB,CAAC;gBACD,IAAI,aAAa,GAAG,KAAK,CAAC;gBAC1B,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;oBACnE,aAAa,GAAG,IAAI,CAAC;gBACvB,CAAC;gBAED,EAAE,CAAC,CAAC,aAAa,IAAI,aAAa,CAAC,CAAC,CAAC;oBACnC,0BAA0B;oBAC1B,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;wBACvB,wBAAwB;wBACxB,iBAAiB,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;oBACxC,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,qBAAqB;oBACrB,EAAE,CAAC,CAAC,QAAQ,YAAY,MAAM,CAAC,CAAC,CAAC;wBAC/B,iBAAiB,GAAG,QAAQ,CAAC,KAAK,CAAC;oBACrC,CAAC;oBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,YAAY,KAAK,CAAC,CAAC,CAAC;wBACrC,wBAAwB;wBACxB,iBAAiB,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;oBACxC,CAAC;gBACH,CAAC;YACH,CAAC;YAED,IAAI,GAAG,GAAG,IAAI,QAAQ,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;YAC/C,IAAI,WAAW,GAAG,gBAAgB,GAAG,IAAI,CAAC,MAAM,GAAG,GAAG,GAAG,SAAS,GAAG,GAAG,GAAG,iBAAiB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACvG,IAAI,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;YAChD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACZ,IAAI,qBAAqB,GAAG,EAAE,CAAC;gBAC/B,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;oBACzC,qBAAqB,IAAI,GAAG,GAAG,iBAAiB,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,GAAG,CAAC,CAAA,0BAA0B;gBACjG,CAAC;gBAED,IAAI,cAAc,GAAG,EAAE,CAAC;gBACxB,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;oBACzC,cAAc,IAAI,UAAU,GAAG,GAAG,GAAG,IAAI,CAAC;gBAC5C,CAAC;gBAED,IAAI,mBAAmB,GAAG,EAAE,CAAC;gBAC7B,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;oBACzC,mBAAmB,IAAI,aAAa,GAAG,GAAG,CAAC;oBAC3C,IAAI,gBAAgB,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAC;oBAC9C,MAAM,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;wBACzB,KAAK,KAAK;4BACR,mBAAmB,IAAI,2DAA2D,CAAC;4BACnF,KAAK,CAAC;wBACR,KAAK,MAAM;4BACT,mBAAmB,IAAI,mFAAmF,CAAC;4BAC3G,KAAK,CAAC;wBACR;4BACE,mBAAmB,IAAI,GAAG,GAAG,gBAAgB,GAAG,wIAAwI,CAAC;4BACzL,KAAK,CAAC;oBACV,CAAC;oBACD,mBAAmB,IAAI,IAAI,CAAC;gBAC9B,CAAC;gBAED,IAAI,UAAU,GAAG;oBACf,eAAe,GAAG,SAAS;oBAC3B,uBAAuB,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;oBAC7C,mBAAmB;oBACnB,sMAAsM;oBACtM,8IAA8I;oBAC9I,qBAAqB;oBACrB,KAAK;oBACL,8BAA8B;oBAC9B,uCAAuC;oBACvC,qKAAqK;oBACrK,6BAA6B;oBAC7B,6BAA6B;oBAC7B,cAAc;oBACd,mCAAmC;oBACnC,GAAG;iBACJ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACb,MAAM,GAAG,GAAG,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;gBAEtC,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC;YAC9C,CAAC;YAED,EAAE,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;gBAClB,IAAI,YAAY,GAAG,EAAE,CAAC,CAAA,6FAA6F;gBACnH,YAAY,CAAC,IAAI,OAAjB,YAAY,EAAS,oBAAoB,CAAC,CAAC;gBAC3C,YAAY,CAAC,IAAI,OAAjB,YAAY,EAAS,mBAAmB,CAAC,CAAC;gBAC1C,YAAY,CAAC,IAAI,OAAjB,YAAY,EAAS,UAAU,CAAC,CAAC;gBACjC,YAAY,CAAC,IAAI,OAAjB,YAAY,EAAS,SAAS,CAAC,CAAC;gBAEhC,IAAI,gBAAgB,GAAG,QAAQ,CAAC,eAAe,CAAC,IAAI,UAAU,CAAC,YAAY,CAAC,EAAE,OAAO,CAAC,CAAC;gBACvF,gBAAgB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;gBAExC,WAAW,CAAC,OAAO,CAAC,EAAE,MAAM,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,EAAE,GAAG,EAAE,EAC9D,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,EAAE,IAAI,EAAE,EAC5C,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,EAAE,gBAAgB,EAAE,EACxD,EAAE,KAAK,EAAE,SAAS,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;gBAC/C,GAAG,CAAC,aAAa,CAAC,MAAM,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;YAEpD,CAAC;YAED,EAAE,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC;gBACtB,GAAG,CAAC,eAAe,CAAC,iBAAiB,CAAC,CAAC;YACzC,CAAC;YAED,MAAM,CAAC,GAAG,CAAC;QACb,CAAC;gBAAS,CAAC;YACT,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACjD,gBAAgB,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;YACjC,CAAC;QACH,CAAC;IACH,CAAC;IAKD,sBAAG,GAAH;QAAI,cAAc;aAAd,WAAc,CAAd,sBAAc,CAAd,IAAc;YAAd,6BAAc;;QAChB,qFAAqF;QACrF,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACrB,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,YAAY,MAAM,CAAC,IAAI,GAAG,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,CAAC,CAAC;YACtD,2BAA2B;YAC3B,GAAG,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QAChD,CAAC;QACD,oCAAoC;QACpC,EAAE,CAAC,CAAC,GAAG,YAAY,MAAM,IAAI,GAAG,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;YAC7C,GAAG,GAAY,GAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtC,CAAC;QAED,IAAI,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,UAAC,CAAC,IAAK,OAAA,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAvB,CAAuB,CAAC,CAAC;QAC5D,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YACf,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAC7B,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAChC,CAAC;IACH,CAAC;IAED,6BAAU,GAAV,UAAW,GAAoB,EAAE,IAAc;QAC7C,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC5B,IAAI,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QACzC,IAAI,UAAkB,CAAC;QACvB,EAAE,CAAC,CAAC,GAAG,YAAY,MAAM,CAAC,CAAC,CAAC;YAC1B,EAAE,CAAC,CAAC,GAAG,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;gBACpB,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;YACzC,CAAC;YACD,UAAU,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACnC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,UAAU,GAAW,GAAG,CAAC;QAC3B,CAAC;QAED,EAAE,CAAC,CAAC,MAAM,CAAC,sBAAsB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC/C,UAAU,GAAG,MAAM,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAChD,CAAC;QAED,IAAI,WAAW,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QACzC,WAAW,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC;QAC5B,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC;IACxE,CAAC;IAEM,wBAAe,GAAtB,UAAuB,GAAW,EAAE,KAAa;QAC/C,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACd,KAAK,OAAO;gBACV,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;gBACd,KAAK,CAAC;YACR,KAAK,OAAO;gBACV,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC;gBACjB,KAAK,CAAC;YACR,KAAK,SAAS;gBACZ,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;gBAClB,KAAK,CAAC;QACV,CAAC;QACD,MAAM,CAAC,GAAG,CAAC;IACb,CAAC;IAED,oCAAiB,GAAjB,UAAkB,GAAoB,EAAE,SAAyB;QAC/D,IAAI,SAAmB,CAAC;QACxB,IAAI,kBAAkB,GAAG,IAAI,CAAC;QAC9B,IAAI,OAAiB,CAAC;QACtB,IAAI,gBAAgB,GAAG,KAAK,CAAC;QAC7B,IAAI,UAAoB,CAAC;QACzB,EAAE,CAAC,CAAC,SAAS,YAAY,KAAK,CAAC,CAAC,CAAC;YAC/B,IAAI,gBAAgB,GAAG,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACpD,UAAU,GAAG,CAAC,CAAC,EAAE,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAA,YAAY;YACtD,SAAS,GAAG,IAAI,QAAQ,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;YAC9C,SAAS,CAAC,KAAK,CAAC,IAAI,UAAU,CAAC,gBAAgB,CAAC,CAAC,CAAC;QACpD,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,SAAS,YAAY,QAAQ,CAAC,CAAC,CAAC;YACzC,SAAS,GAAG,SAAS,CAAC;YACtB,kBAAkB,GAAG,KAAK,CAAC;QAC7B,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,SAAS,YAAY,MAAM,CAAC,CAAC,CAAC;YACvC,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;QACjD,CAAC;QAED,IAAI,CAAC;YACH,EAAE,CAAC,CAAC,GAAG,YAAY,MAAM,CAAC,CAAC,CAAC;gBAC1B,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;oBACnC,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;gBACxC,CAAC;gBAED,EAAE,CAAC,CAAC,GAAG,YAAY,QAAQ,CAAC,CAAC,CAAC;oBAC5B,OAAO,GAAG,GAAG,CAAC;gBAChB,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;oBACvC,gBAAgB,GAAG,IAAI,CAAC;gBAC1B,CAAC;gBAED,IAAI,WAAW,GAAG,2BAA2B,GAAG,IAAI,CAAC,MAAM,GAAG,GAAG,GAAG,OAAO,CAAC,MAAM,GAAG,GAAG,GAAG,SAAS,CAAC,MAAM,CAAC;gBAC5G,IAAI,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;gBAChD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;oBACZ,MAAM,GAAG,GAAG,CAAC,YAAY,CAAC;wBACxB,mBAAmB,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC;wBAC5C,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;wBACzC,qBAAqB,GAAG,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC;wBAChD,uBAAuB,GAAG,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,MAAM,CAAC;wBAC5E,4HAA4H;wBAC5H,8BAA8B;wBAC9B,sCAAsC;wBACtC,8CAA8C;wBAC9C,GAAG;qBACJ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;oBACd,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC;gBAC9C,CAAC;gBACD,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBACzB,GAAG,CAAC,aAAa,CAAC,MAAM,EAAE;wBACxB,EAAE,MAAM,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,EAAE,IAAI,EAAE;wBAC7C,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,EAAE,OAAO,EAAE;wBAC/C,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,EAAE,SAAS,EAAE;wBACjD,EAAE,KAAK,EAAE,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE;qBACnD,EAAE,SAAS,CAAC,MAAM,CAAC,CAAC;gBACvB,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,WAAW,GAAG,2BAA2B,GAAG,IAAI,CAAC,MAAM,GAAG,GAAG,GAAG,SAAS,CAAC,MAAM,CAAC;gBACrF,IAAI,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;gBAChD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;oBACZ,MAAM,GAAG,GAAG,CAAC,YAAY,CAAC;wBACxB,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;wBACzC,qBAAqB,GAAG,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC;wBAChD,kHAAkH;wBAClH,8BAA8B;wBAC9B,sCAAsC;wBACtC,gCAAgC;wBAChC,GAAG;qBACJ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;oBACd,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC;gBAC9C,CAAC;gBACD,IAAI,UAAU,GAAG,QAAQ,CAAC,eAAe,CAAS,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;gBACpE,EAAE,CAAC,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBACzB,GAAG,CAAC,aAAa,CAAC,MAAM,EAAE;wBACxB,EAAE,MAAM,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,EAAE,IAAI,EAAE;wBAC7C,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;wBACpD,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,EAAE,SAAS,EAAE;wBACjD,EAAE,KAAK,EAAE,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE;qBACnD,EAAE,SAAS,CAAC,MAAM,CAAC,CAAC;gBACvB,CAAC;YACH,CAAC;QACH,CAAE;QAAA,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACf,MAAM,KAAK,CAAC;QACd,CAAC;gBAAS,CAAC;YACT,EAAE,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC;gBACvB,SAAS,CAAC,QAAQ,EAAE,CAAC;YACvB,CAAC;QACH,CAAC;IAEH,CAAC;IAGD,gCAAa,GAAb,UAAc,GAAoB,EAAE,IAAiC;QACnE,IAAI,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC;QAC5B,IAAI,gBAAgB,GAAa,EAAE,CAAC;QACpC,IAAI,CAAC;YACH,qCAAqC;YACrC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC;gBACnC,IAAI,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBAClB,EAAE,CAAC,CAAC,GAAG,YAAY,MAAM,CAAC,CAAC,CAAC;oBAC1B,EAAE,CAAC,CAAC,GAAG,CAAC,MAAM,IAAI,SAAS,CAAC,CAAC,CAAC;wBAC5B,IAAI,QAAQ,GAAG,GAAG,CAAC,KAAK,EAAE,CAAC;wBAC3B,IAAI,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAA;wBAClB,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;oBAClC,CAAC;gBACH,CAAC;YACH,CAAC;YAED,IAAI,mBAAmB,GAAa,EAAE,CAAC;YACvC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,SAAS,CAAC,CAAC,CAAC;gBAC7B,aAAa;gBACb,mBAAmB,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;gBAC1C,OAAO,mBAAmB,CAAC,MAAM,GAAG,SAAS,EAAE,CAAC;oBAC9C,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC9B,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,sCAAsC;gBACtC,IAAI,QAAQ,GAAG,CAAC,CAAC;gBACjB,GAAG,CAAC,CAAC,IAAI,KAAG,GAAG,CAAC,EAAE,KAAG,GAAG,SAAS,GAAG,CAAC,EAAE,KAAG,EAAE,EAAE,CAAC;oBAC7C,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAG,CAAC,CAAC,CAAC;oBAC1C,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,KAAG,CAAC,CAAC;gBAC9B,CAAC;gBACD,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,CAAC;YACnD,CAAC;YACD,IAAI,oBAAoB,GAAa,EAAE,CAAC;YACxC,IAAI,UAAU,GAAG,CAAC,CAAC;YACnB,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;gBACzC,oBAAoB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBACtC,UAAU,IAAI,mBAAmB,CAAC,GAAG,CAAC,CAAC;YACzC,CAAC;YAED,IAAI,WAAW,GAAG,EAAE,CAAC;YACrB,IAAI,iBAAiB,GAAG,EAAE,CAAC;YAC3B,IAAI,SAAS,GAAG,EAAE,CAAC;YACnB,IAAI,UAAU,GAAG,EAAE,CAAC,CAAA,6DAA6D;YACjF,IAAI,cAAc,GAAG,CAAC,CAAC;YACvB,IAAI,kBAAkB,GAAG,EAAE,CAAC;YAC5B,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;gBACzC,IAAI,eAAe,GAAG,QAAQ,CAAC,oBAAoB,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC;gBACzF,EAAE,CAAC,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC,CAAC;oBAChC,gBAAgB,CAAC,IAAI,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC;gBACrD,CAAC;gBACD,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC;gBAC7C,iBAAiB,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;gBACjD,SAAS,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;gBACvC,EAAE,CAAC,CAAC,eAAe,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;oBAChC,kBAAkB,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;gBAClD,CAAC;gBACD,UAAU,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;gBAChC,cAAc,IAAI,eAAe,CAAC,MAAM,CAAC;YAC3C,CAAC;YACD,IAAI,SAAS,GAAG,cAAc,CAAC;YAE/B,IAAI,aAAa,GAAG,KAAK,CAAC;YAC1B,EAAE,CAAC,CAAC,GAAG,YAAY,MAAM,CAAC,CAAC,CAAC;gBAC1B,EAAE,CAAC,CAAU,GAAI,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC9B,0BAA0B;oBAC1B,GAAG,GAAY,GAAI,CAAC,GAAG,EAAE,CAAC;gBAC5B,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,aAAa,GAAG,IAAI,CAAC;oBACrB,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,YAAY,QAAQ,CAAC,CAAC,CAAC,CAAC;wBAC/B,aAAa;wBACb,GAAG,GAAG,QAAQ,CAAC,cAAc,CAAS,GAAG,CAAC,CAAC;wBAC3C,gBAAgB,CAAC,IAAI,CAAS,GAAG,CAAC,CAAC;oBACrC,CAAC;gBACH,CAAC;YACH,CAAC;YAED,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;gBAClB,cAAc;gBACd,0DAA0D;gBAC1D,8CAA8C;gBAC9C,IAAI,SAAS,GAAY,GAAI,CAAC,MAAM,CAAC;gBAErC,IAAI,WAAW,GAAG,KAAK,CAAC;gBACxB,EAAE,CAAC,CAAC,kBAAkB,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;oBACnC,gBAAgB;oBAChB,EAAE,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,CAAC,CAAC;wBACnB,WAAW,GAAG,IAAI,CAAC;oBACrB,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,kBAAkB,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC1C,EAAE,CAAC,CAAC,SAAS,IAAI,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBACvC,WAAW,GAAG,IAAI,CAAC;oBACrB,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,IAAI,SAAS,GAAY,GAAI,CAAC,KAAK,CAAC;oBACpC,IAAI,kBAAkB,GAAG,SAAS,CAAC,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,IAAI,CAAC,EAAN,CAAM,CAAC,CAAC;oBACzD,EAAE,CAAC,CAAC,CAAC,kBAAkB,CAAC,KAAK,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,IAAI,kBAAkB,CAAC,CAAC,CAAC,EAA1B,CAA0B,CAAC,CAAC,CAAC,CAAC;wBACpE,WAAW,GAAG,IAAI,CAAC;oBACrB,CAAC;gBACH,CAAC;gBAED,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;oBAChB,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;gBACtD,CAAC;YACH,CAAC;YAED,IAAI,WAAW,GAAG,gBAAgB,GAAG,IAAI,CAAC,MAAM,GAAG,GAAG,GAAG,aAAa,GAAG,GAAG,GAAG,SAAS,GAAG,GAAG,GAAG,iBAAiB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YAC7H,IAAI,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;YAChD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACZ,IAAI,qBAAqB,GAAG,EAAE,CAAC;gBAC/B,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;oBACzC,qBAAqB,IAAI,GAAG,GAAG,iBAAiB,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,GAAG,CAAC,CAAA,0BAA0B;gBACjG,CAAC;gBAED,IAAI,cAAc,GAAG,EAAE,CAAC;gBACxB,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;oBACzC,cAAc,IAAI,UAAU,GAAG,GAAG,GAAG,IAAI,CAAC;gBAC5C,CAAC;gBAED,IAAI,mBAAmB,GAAG,EAAE,CAAC;gBAC7B,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,EAAE,GAAG,EAAE,EAAE,CAAC;oBACzC,mBAAmB,IAAI,aAAa,GAAG,GAAG,CAAC;oBAC3C,IAAI,gBAAgB,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAC;oBAC9C,MAAM,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC;wBACzB,KAAK,KAAK;4BACR,mBAAmB,IAAI,2DAA2D,CAAC;4BACnF,KAAK,CAAC;wBACR,KAAK,MAAM;4BACT,mBAAmB,IAAI,mFAAmF,CAAC;4BAC3G,KAAK,CAAC;wBACR;4BACE,mBAAmB,IAAI,GAAG,GAAG,gBAAgB,GAAG,wIAAwI,CAAC;4BACzL,KAAK,CAAC;oBACV,CAAC;oBACD,mBAAmB,IAAI,IAAI,CAAC;gBAC9B,CAAC;gBAED,IAAI,UAAU,GAAG;oBACf,eAAe,GAAG,SAAS;oBAC3B,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;oBACzC,mBAAmB,GAAG,MAAM,CAAC,aAAa,GAAY,GAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;oBAChF,uBAAuB,GAAG,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,EAAE,aAAa,GAAY,GAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;oBAChH,mBAAmB;oBACnB,sMAAsM;oBACtM,4BAA4B;oBAC5B,aAAa,GAAG,8BAA8B,GAAG,cAAc;oBAC/D,gFAAgF;oBAChF,qBAAqB;oBACrB,KAAK;oBACL,8BAA8B;oBAC9B,uCAAuC;oBACvC,qKAAqK;oBACrK,6BAA6B;oBAC7B,6BAA6B;oBAC7B,cAAc;oBACd,aAAa,GAAG,8CAA8C,GAAG,2CAA2C;oBAC5G,GAAG;iBACJ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACb,MAAM,GAAG,GAAG,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;gBAEtC,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC;YAC9C,CAAC;YAED,EAAE,CAAC,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;gBAClB,IAAI,YAAY,GAAG,EAAE,CAAC,CAAA,6FAA6F;gBACnH,YAAY,CAAC,IAAI,OAAjB,YAAY,EAAS,oBAAoB,CAAC,CAAC;gBAC3C,YAAY,CAAC,IAAI,OAAjB,YAAY,EAAS,mBAAmB,CAAC,CAAC;gBAC1C,YAAY,CAAC,IAAI,OAAjB,YAAY,EAAS,UAAU,CAAC,CAAC;gBACjC,YAAY,CAAC,IAAI,OAAjB,YAAY,EAAS,SAAS,CAAC,CAAC;gBAEhC,IAAI,gBAAgB,GAAG,QAAQ,CAAC,eAAe,CAAC,IAAI,UAAU,CAAC,YAAY,CAAC,EAAE,OAAO,CAAC,CAAC;gBACvF,gBAAgB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;gBAExC,WAAW,CAAC,OAAO,CACjB,EAAE,MAAM,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,EAAE,IAAI,EAAE,EAC7C,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,EAAE,gBAAgB,EAAE,EACxD,EAAE,KAAK,EAAE,SAAS,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;gBAC/C,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;oBAClB,WAAW,CAAC,OAAO,CAAC,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC;gBACnE,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,WAAW,CAAC,OAAO,CAAC,EAAE,KAAK,EAAU,GAAG,EAAE,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;gBAC7E,CAAC;gBACD,GAAG,CAAC,aAAa,CAAC,MAAM,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;YAEpD,CAAC;QAEH,CAAC;gBAAS,CAAC;YACT,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACjD,gBAAgB,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;YACjC,CAAC;QACH,CAAC;IACH,CAAC;IAED,wBAAK,GAAL;QACE,2BAA2B;QAE3B,0BAA0B;QAC1B,IAAI,SAAS,GAAG,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;QAC9C,IAAI,WAAW,GAAG,oBAAoB,GAAG,IAAI,CAAC,MAAM,CAAC;QACrD,IAAI,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;QAChD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACZ,MAAM,GAAG,GAAG,CAAC,YAAY,CAAC;gBACxB,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACzC,gGAAgG;gBAChG,gBAAgB;gBAChB,mBAAmB;gBACnB,uCAAuC;gBACvC,sCAAsC;gBACtC,sCAAsC;gBACtC,gBAAgB;gBAChB,cAAc;gBACd,kBAAkB;gBAClB,OAAO;gBACP,KAAK;gBACL,mBAAmB;gBACnB,qBAAqB;gBACrB,GAAG;aACJ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACd,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC;QAC9C,CAAC;QAED,IAAI,WAAW,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC,CAAA,iBAAiB;QACrD,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACpB,GAAG,CAAC,aAAa,CAAC,MAAM,EAAE;gBACxB,EAAE,MAAM,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,EAAE,SAAS,EAAE;gBAClD,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,EAAE,IAAI,EAAE;gBAC5C,EAAE,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE;aAC9C,EAAE,CAAC,CAAC,CAAC;YACN,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC9B,CAAC;QAED,IAAI,aAAa,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QACnC,IAAI,KAAK,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QAE3B,uBAAuB;QACvB,IAAI,MAAM,GAAG,IAAI,QAAQ,CAAC,CAAC,aAAa,EAAE,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;QACvD,IAAI,WAAW,GAAG,oBAAoB,GAAG,IAAI,CAAC,MAAM,CAAC;QACrD,IAAI,MAAM,GAAG,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;QAChD,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;YACZ,MAAM,GAAG,GAAG,CAAC,YAAY,CAAC;gBACxB,mBAAmB,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;gBACzC,4FAA4F;gBAC5F,8BAA8B;gBAC9B,0BAA0B;gBAC1B,oBAAoB;gBACpB,mBAAmB;gBACnB,qCAAqC;gBACrC,wBAAwB;gBACxB,oCAAoC;gBACpC,OAAO;gBACP,eAAe;gBACf,KAAK;gBACL,GAAG;aACJ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YACd,QAAQ,CAAC,YAAY,CAAC,WAAW,CAAC,GAAG,MAAM,CAAC;QAC9C,CAAC;QAED,EAAE,CAAC,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;YACtB,GAAG,CAAC,aAAa,CAAC,MAAM,EAAE;gBACxB,EAAE,MAAM,EAAE,KAAK,CAAC,cAAc,EAAE,KAAK,EAAE,MAAM,EAAE;gBAC/C,EAAE,MAAM,EAAE,KAAK,CAAC,aAAa,EAAE,KAAK,EAAE,IAAI,EAAE;gBAC5C,EAAE,KAAK,EAAE,aAAa,EAAE,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE;aAChD,EAAE,CAAC,CAAC,CAAC;QACR,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YACjC,aAAa;YACb,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACrC,CAAC;QAED,SAAS,CAAC,QAAQ,EAAE,CAAC;QAErB,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IAj4BM,qBAAY,GAAG,EAAE,CAAC;IAm4B3B,eAAC;AAAD,CAAC,AAr4BD,CAAuB,MAAM,GAq4B5B;AAED,iBAAS,QAAQ,CAAC","sourcesContent":["// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\nimport Matrix = require('../matrix');\nimport Colon = require('../colon');\nimport typedef = require('../typedef');\nimport $CL = require('./handwrittenjs/driver');\nvar WebCL = $CL.WebCL;\n\nvar ctypes = { single: 'float', int32: 'int', uint8: 'uchar', logical: 'uchar' };\nvar webcltypes = { single: WebCL.type.FLOAT, int32: WebCL.type.INT, uint8: WebCL.type.UCHAR, logical: WebCL.type.UCHAR };\n\ntype AllowedTypedArray = typedef.AllowedTypedArray;\n\nclass MatrixCL extends Matrix {\n  _clbuffer: $CL.clBuffer;\n  static kernel_cache = {};\n  constructor(size: number[], klass?: string) {\n    super(size, klass, true);\n    var buffer_size = this._numel * this._data_ctor.BYTES_PER_ELEMENT;\n    if (this._numel == 0) {\n      // buffer of 0 byte cannot be constructed, but allocate buffer to avoid exception\n      buffer_size = 4;\n    }\n    this._clbuffer = $CL.createBuffer(buffer_size);\n  }\n\n  to_cpu(): Matrix {\n    var cpumat = new Matrix(this._size, this._klass);\n    this.read(cpumat._data);\n    return cpumat;\n  }\n\n  private throw_if_destructed() {\n    if (!this._clbuffer) {\n      throw new Error('Attempting use destructed matrix');\n    }\n  }\n\n  write(src_typed_array: any, dst_bytes_offset?: number) {\n    this.throw_if_destructed();\n    if (src_typed_array.length > 0) {\n      $CL.writeBuffer(this._clbuffer, src_typed_array, dst_bytes_offset);\n    }\n  }\n\n  read(dst_typed_array: any, src_bytes_offset?: number) {\n    this.throw_if_destructed();\n    if (dst_typed_array.length > 0) {\n      $CL.readBuffer(this._clbuffer, dst_typed_array, src_bytes_offset);\n    }\n  }\n\n  static _fromnativemat(A: Matrix): MatrixCL {\n    if (A instanceof MatrixCL) {\n      return <MatrixCL>A.copy();\n    } else {\n      var matcl = new MatrixCL(A._size, A._klass);\n      matcl.write(A._getdata());\n      return matcl;\n    }\n  }\n\n  static _fromtypedarray(src_typed_array: typedef.AllowedTypedArray, klass: string): MatrixCL {\n    var mat = new MatrixCL([1, src_typed_array.length], klass);\n    mat.write(src_typed_array);\n    return mat;\n  }\n\n  destruct() {\n    if (this._clbuffer) {\n      $CL.releaseBuffer(this._clbuffer);\n      this._clbuffer = null;\n    }\n  }\n\n  inspect(depth: number): string {\n    var shape_str = this._size.join('x');\n    if (this._numel <= 100) {\n      return 'MatrixCL ' + shape_str + ' ' + this._klass + '\\n' + this.toString();\n    } else {\n      return 'MatrixCL ' + shape_str + ' ' + this._klass;\n    }\n  }\n\n  _getdata(): typedef.AllowedTypedArray {\n    //get copy of data in TypedArray\n    var typed_array = new this._data_ctor(this._numel);\n    this.read(typed_array);\n    return typed_array;\n  }\n\n  getdataref(src_offset: number = 0, length?: number): typedef.AllowedTypedArray {\n    //get read-only view of array\n    // copy minimum range of gpu array\n    if (length == null) {\n      length = this._numel - src_offset;\n    }\n    var typed_array = new this._data_ctor(length);\n    this.read(typed_array, src_offset * this._data_ctor.BYTES_PER_ELEMENT);\n    return typed_array;\n  }\n\n  getdatacopy(src_offset: number = 0, length?: number, dst?: typedef.AllowedTypedArray): typedef.AllowedTypedArray {\n    if (length == null) {\n      length = this._numel - src_offset;\n    }\n    if (!dst) {\n      dst = new this._data_ctor(length);\n    }\n\n    var range_view = new this._data_ctor(dst.buffer, dst.byteOffset, length);\n    this.read(range_view, src_offset * this._data_ctor.BYTES_PER_ELEMENT);\n\n    return dst;\n  }\n\n  setdata(src: typedef.AllowedTypedArray, dst_offset: number = 0): void {\n    //set raw data into buffer\n    this.write(src, dst_offset * this._data_ctor.BYTES_PER_ELEMENT);\n  }\n\n  static get_cast_str(dst_klass: string, src_klass: string): string {\n    var cast_str: string;\n    if (src_klass == dst_klass) {\n      cast_str = '(x)';\n    } else if (dst_klass != 'logical') {\n      cast_str = '(' + dst_klass + ')(x)';\n    } else {\n      cast_str = '((x != 0) ? 1 : 0)';\n    }\n    return cast_str;\n  }\n\n  copy(klass?: string): Matrix {\n    var clone = new MatrixCL(this._size, klass || this._klass);\n    var kernel_name = 'copy_' + clone._klass + '_' + this._klass;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define DST_TYPE ' + ctypes[clone._klass],\n        '#define SRC_TYPE ' + ctypes[this._klass],\n        '#define TYPE_CAST(x) ' + MatrixCL.get_cast_str(clone._klass, this._klass),\n        '__kernel void kernel_func(__global DST_TYPE *dst, __global SRC_TYPE *src, uint length) {',\n        '  uint i = get_global_id(0);',\n        '  if (i >= length) { return; }',\n        '  dst[i] = TYPE_CAST(src[i]);',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    if (this._numel > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: clone },\n        { access: WebCL.MEM_READ_ONLY, datum: this },\n        { datum: this._numel, type: WebCL.type.UINT }\n      ], this._numel);\n    }\n    return clone;\n  }\n\n  _fill(val: number): void {\n    var kernel_name = 'fill_' + this._klass;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define DST_TYPE ' + ctypes[this._klass],\n        '__kernel void kernel_func(__global DST_TYPE *dst, uint length, DST_TYPE val) {',\n        '  uint i = get_global_id(0);',\n        '  if (i >= length) { return; }',\n        '  dst[i] = val;',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    if (this._numel > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: this },\n        { datum: this._numel, type: WebCL.type.UINT },\n        { datum: val, type: webcltypes[this._klass] }\n      ], this._numel);\n    }\n  }\n\n  get(): number;\n  get(...args: number[]): number;\n  get(...args: any[]): Matrix;\n  get(...args: any[]): any {\n    if (args.length == 0) {\n      // get scalar\n      return this.get_scalar([1]);\n    }\n    var all_number = args.every((v) => typeof (v) === 'number');\n    if (all_number) {\n      return this.get_scalar(args);\n    } else {\n      return this.get_matrix_nd(args);\n    }\n  }\n\n  get_scalar(inds: number[]): number {\n    this._isvalidindexerr(inds);\n    var arrayidx = this._getarrayindex(inds);\n    var dst_typed_array = new this._data_ctor(1);//read only 1 element\n    this.read(dst_typed_array, arrayidx * this._data_ctor.BYTES_PER_ELEMENT);\n    return dst_typed_array[0];\n  }\n\n  private static _get_ind_iterator_cl(ind: (number | Colon | Matrix), dim_size: number): { kernel_arg: { access?: any, datum: any, type?: any }, to_destruct: MatrixCL, length: number, typename: string } {\n    // return index within valid range\n    if (typeof (ind) === 'number') {\n      var ind_positive = <number>ind;\n      if (ind_positive < 0) {//end-xxx\n        ind_positive += dim_size + 1;\n      }\n      if (ind_positive <= 0 || ind_positive > dim_size) {\n        throw Error('Index exceeds matrix dimension');\n      }\n      return {\n        kernel_arg: { datum: ind_positive, type: webcltypes.int32 },\n        to_destruct: null, length: 1,\n        typename: 'int'\n      };\n    } else if (ind instanceof Colon) {\n      var start = ind.start;\n      var stop = ind.stop;\n      var step = ind.step;\n      if (ind.all) {\n        start = 1;\n        stop = dim_size;\n        step = 1;\n      }\n      if (start < 0) {\n        start += dim_size + 1;\n      }\n      if (stop < 0) {\n        stop += dim_size + 1;\n      }\n      var length: number = 0;\n      if ((step > 0 && stop >= start) || (step < 0 && stop <= start)) {\n        length = Math.floor((stop - start) / step) + 1;\n        // check if in valid range\n        var final_value = start + step * (length - 1);\n        if ((start <= 0 || start > dim_size) || (final_value <= 0 || final_value > dim_size)) {\n          throw Error('Index exceeds matrix dimension');\n        }\n      }\n      return {\n        kernel_arg: { datum: [start, step, stop, length], type: webcltypes.int32 | WebCL.type.VEC4 },\n        to_destruct: null,\n        length: length,\n        typename: 'int4'\n      }\n    } else if (ind instanceof Matrix) {\n      var to_destruct = null;\n      var ind_mat: MatrixCL;\n      if (ind instanceof MatrixCL) {\n        ind_mat = ind;\n      } else {\n        ind_mat = MatrixCL._fromnativemat(ind);\n        to_destruct = ind_mat;\n      }\n      // check if in valid range\n\n      var kernel_name = '_get_ind_iterator_cl_' + ind._klass;\n      var kernel = MatrixCL.kernel_cache[kernel_name];\n      if (!kernel) {\n        var kernel_str = [\n          '#define SRC_TYPE ' + ctypes[ind._klass],\n          '__kernel void kernel_func(__global int *dst, __global const SRC_TYPE *src, int dim_size, uint src_length) {',\n          '  uint i = get_global_id(0);',\n          '  if (i >= src_length) { return; }',\n          '  int src_val = (int)src[i];',\n          '  if (src_val == 0 || src_val > dim_size || src_val < -dim_size) {',\n          '    dst[0] = 1;',\n          '  }',\n          '}'\n        ].join('\\n');\n        kernel = $CL.createKernel(kernel_str);\n        MatrixCL.kernel_cache[kernel_name] = kernel;\n      }\n      if (ind_mat._numel > 0) {\n        var validity_result = new MatrixCL([1, 1], 'int32');\n        validity_result._fill(0);\n        $CL.executeKernel(kernel, [\n          { access: WebCL.MEM_WRITE_ONLY, datum: validity_result },\n          { access: WebCL.MEM_READ_ONLY, datum: ind_mat },\n          { datum: dim_size, type: WebCL.type.INT },\n          { datum: ind_mat._numel, type: WebCL.type.UINT }\n        ], ind_mat._numel);\n        if (validity_result.getdataref()[0]) {\n          validity_result.destruct();\n          if (to_destruct) {\n            to_destruct.destruct();\n          }\n          throw Error('Index exceeds matrix dimension');\n        }\n        validity_result.destruct();\n      }\n\n      return {\n        kernel_arg: { datum: ind_mat, access: WebCL.MEM_READ_ONLY },\n        to_destruct: to_destruct,\n        length: ind_mat._numel,\n        typename: '__global ' + ctypes[ind_mat._klass] + ' *'\n      }\n    }\n  }\n\n  get_matrix_nd(inds: (number | Colon | Matrix)[]): Matrix {\n    var inds_ndim = inds.length;\n    var destruct_targets: Matrix[] = [];\n    try {\n      // replace logical matrix with vector\n      for (var i = 0; i < inds_ndim; i++) {\n        var ind = inds[i];\n        if (ind instanceof Matrix) {\n          if (ind._klass == 'logical') {\n            var idxarray = ind._find();\n            inds[i] = idxarray\n            destruct_targets.push(idxarray);\n          }\n        }\n      }\n\n      var virtual_input_shape: number[] = [];\n      if (this._ndims <= inds_ndim) {\n        // pad with 1\n        virtual_input_shape = this._size.concat();\n        while (virtual_input_shape.length < inds_ndim) {\n          virtual_input_shape.push(1);\n        }\n      } else {\n        // last dimension is like linear index\n        let cur_prod = 1;\n        for (let dim = 0; dim < inds_ndim - 1; dim++) {\n          virtual_input_shape.push(this._size[dim]);\n          cur_prod *= this._size[dim];\n        }\n        virtual_input_shape.push(this._numel / cur_prod);\n      }\n      var virtual_input_stride: number[] = [];\n      var stride_tmp = 1;\n      for (var dim = 0; dim < inds_ndim; dim++) {\n        virtual_input_stride.push(stride_tmp);\n        stride_tmp *= virtual_input_shape[dim];\n      }\n\n      var kernel_args = [];\n      var kernel_type_names = [];\n      var dst_shape = [];\n      var dst_stride = [];//not use dst._strides because tailing 1 dimension is omitted\n      var dst_stride_tmp = 1;\n      for (var dim = 0; dim < inds_ndim; dim++) {\n        var iter_and_length = MatrixCL._get_ind_iterator_cl(inds[dim], virtual_input_shape[dim]);\n        if (iter_and_length.to_destruct) {\n          destruct_targets.push(iter_and_length.to_destruct);\n        }\n        kernel_args.push(iter_and_length.kernel_arg);\n        kernel_type_names.push(iter_and_length.typename);\n        dst_shape.push(iter_and_length.length);\n        dst_stride.push(dst_stride_tmp);\n        dst_stride_tmp *= iter_and_length.length;\n      }\n      var dst_numel = dst_stride_tmp;\n\n      var dst_reshape_shape = null;\n      if (inds_ndim == 1) {\n        // linear indexing case\n        dst_shape.push(1);//avoid error on new Matrix()\n        // if ind is logical matrix, regarded as vector in the following\n        // colon is row vector\n        // src and ind are both vectors => follows direction of src\n        // otherwise: follows ind's shape\n        var is_ind_vector = false;\n        var only_ind = inds[0];\n        if (only_ind instanceof Matrix) {\n          if (only_ind._ndims == 2 && (only_ind._size[0] == 1 || only_ind._size[1] == 1)) {\n            is_ind_vector = true;\n          }\n        } else if (only_ind instanceof Colon) {\n          is_ind_vector = true;\n        }\n        var is_src_vector = false;\n        if (this._ndims == 2 && (this._size[0] == 1 || this._size[1] == 1)) {\n          is_src_vector = true;\n        }\n\n        if (is_src_vector && is_ind_vector) {\n          // follow direction of src\n          if (this._size[0] == 1) {\n            // reshape to row vector\n            dst_reshape_shape = [1, dst_shape[0]];\n          }\n        } else {\n          // follow ind's shape\n          if (only_ind instanceof Matrix) {\n            dst_reshape_shape = only_ind._size;\n          } else if (only_ind instanceof Colon) {\n            // reshape to row vector\n            dst_reshape_shape = [1, dst_shape[0]];\n          }\n        }\n      }\n\n      var dst = new MatrixCL(dst_shape, this._klass);\n      var kernel_name = 'get_matrix_nd_' + this._klass + '_' + inds_ndim + '_' + kernel_type_names.join(',');\n      var kernel = MatrixCL.kernel_cache[kernel_name];\n      if (!kernel) {\n        var kernel_index_args_str = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_index_args_str += ',' + kernel_type_names[dim] + ' ind' + dim;//variable ind0, ind1, ...\n        }\n\n        var kernel_add_dim = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_add_dim += 'ADD_IND(' + dim + ');';\n        }\n\n        var kernel_get_ind_func = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_get_ind_func += 'int get_ind' + dim;\n          var kernel_type_name = kernel_type_names[dim];\n          switch (kernel_type_name) {\n            case 'int':\n              kernel_get_ind_func += '(int indexer, int offset, int dim_size) {return indexer;}';\n              break;\n            case 'int4':\n              kernel_get_ind_func += '(int4 indexer, int offset, int dim_size) {return indexer.x + indexer.y * offset;}';\n              break;\n            default:\n              kernel_get_ind_func += '(' + kernel_type_name + ' indexer, int offset, int dim_size) {int val = (int)indexer[offset]; if (val < 0) { return val + dim_size + 1; } else { return val; }}';\n              break;\n          }\n          kernel_get_ind_func += '\\n';\n        }\n\n        var kernel_str = [\n          '#define DIMS ' + inds_ndim,\n          '#define SRC_DST_TYPE ' + ctypes[this._klass],\n          kernel_get_ind_func,\n          '#define ADD_IND(dim) {dst_coord = (i / dst_stride[dim]) % dst_shape[dim]; src_coord = (get_ind ## dim(ind ## dim, dst_coord, src_shape[dim])) - 1; src_linear_index += src_coord * src_stride[dim];}',\n          '__kernel void kernel_func(__global SRC_DST_TYPE *dst, __global const SRC_DST_TYPE *src, __global const int *size_strides, uint output_length',\n          kernel_index_args_str,\n          ') {',\n          '  uint i = get_global_id(0);',\n          '  if (i >= output_length) { return; }',\n          '  __global const int *src_stride = size_strides, *src_shape = size_strides + DIMS * 1, *dst_stride = size_strides + DIMS * 2, *dst_shape = size_strides + DIMS * 3;',\n          '  int dst_coord, src_coord;',\n          '  int src_linear_index = 0;',\n          kernel_add_dim,\n          '  dst[i] = src[src_linear_index];',\n          '}'\n        ].join('\\n');\n        kernel = $CL.createKernel(kernel_str);\n\n        MatrixCL.kernel_cache[kernel_name] = kernel;\n      }\n\n      if (dst_numel > 0) {\n        var size_strides = [];//src_stride/src_shape/dst_stride/dst_shape; dst_shape is last because [1] may be added above\n        size_strides.push(...virtual_input_stride);\n        size_strides.push(...virtual_input_shape);\n        size_strides.push(...dst_stride);\n        size_strides.push(...dst_shape);\n\n        var size_strides_mat = MatrixCL._fromtypedarray(new Int32Array(size_strides), 'int32');\n        destruct_targets.push(size_strides_mat);\n\n        kernel_args.unshift({ access: WebCL.MEM_WRITE_ONLY, datum: dst },\n          { access: WebCL.MEM_READ_ONLY, datum: this },\n          { access: WebCL.MEM_READ_ONLY, datum: size_strides_mat },\n          { datum: dst_numel, type: WebCL.type.UINT });\n        $CL.executeKernel(kernel, kernel_args, dst_numel);\n\n      }\n\n      if (dst_reshape_shape) {\n        dst.reshape_inplace(dst_reshape_shape);\n      }\n\n      return dst;\n    } finally {\n      for (var i = 0; i < destruct_targets.length; i++) {\n        destruct_targets[i].destruct();\n      }\n    }\n  }\n\n  set(ind: number | Matrix | Colon, val: number | Matrix | any[]): void;\n  set(row: number | Matrix | Colon, col: number | Matrix | Colon, val: number | Matrix | any[]): void;\n  set(...args: any[]): void;\n  set(...args: any[]): void {\n    //last argument is value, but subsequent function requires first argument to be value\n    var val = args.pop();\n    if (!(val instanceof Matrix) && val.length !== void 0) {\n      // js array (or array-like)\n      val = Matrix.jsa2mat(val, false, this._klass);\n    }\n    // scalar matrix converted to number\n    if (val instanceof Matrix && val._numel == 1) {\n      val = (<Matrix>val).get_scalar([1]);\n    }\n\n    var all_number = args.every((v) => typeof (v) === 'number');\n    if (all_number) {\n      this.set_scalar(val, args);\n    } else {\n      this.set_matrix_nd(val, args);\n    }\n  }\n\n  set_scalar(val: number | Matrix, inds: number[]): void {\n    this._isvalidindexerr(inds);\n    var arrayidx = this._getarrayindex(inds);\n    var scalar_val: number;\n    if (val instanceof Matrix) {\n      if (val._numel != 1) {\n        throw new Error('Value is not scalar');\n      }\n      scalar_val = val.get_scalar([1]);\n    } else {\n      scalar_val = <number>val;\n    }\n\n    if (Matrix._logical_cast_required(this._klass)) {\n      scalar_val = Matrix._logical_cast(scalar_val);\n    }\n\n    var typed_array = new this._data_ctor(1);\n    typed_array[0] = scalar_val;\n    this.write(typed_array, arrayidx * this._data_ctor.BYTES_PER_ELEMENT);\n  }\n\n  static cast_scalar_val(val: number, klass: string): number {\n    switch (klass) {\n      case 'int32':\n        val = val | 0;\n        break;\n      case 'uint8':\n        val = val & 0xFF;\n        break;\n      case 'logical':\n        val = val ? 1 : 0;\n        break;\n    }\n    return val;\n  }\n\n  set_matrix_single(val: number | Matrix, singleind: Colon | Matrix): void {\n    var index_mat: MatrixCL;\n    var destruct_index_mat = true;\n    var val_mat: MatrixCL;\n    var destruct_val_mat = false;\n    var input_size: number[];\n    if (singleind instanceof Colon) {\n      var single_idx_array = singleind.tojsa(this._numel);\n      input_size = [1, single_idx_array.length];//row vector\n      index_mat = new MatrixCL(input_size, 'int32');\n      index_mat.write(new Int32Array(single_idx_array));\n    } else if (singleind instanceof MatrixCL) {\n      index_mat = singleind;\n      destruct_index_mat = false;\n    } else if (singleind instanceof Matrix) {\n      index_mat = MatrixCL._fromnativemat(singleind);\n    }\n\n    try {\n      if (val instanceof Matrix) {\n        if (index_mat._numel != val._numel) {\n          throw new Error('Dimension mismatch');\n        }\n\n        if (val instanceof MatrixCL) {\n          val_mat = val;\n        } else {\n          val_mat = MatrixCL._fromnativemat(val);\n          destruct_val_mat = true;\n        }\n\n        var kernel_name = 'set_matrix_single_matrix_' + this._klass + '_' + val_mat._klass + '_' + index_mat._klass;\n        var kernel = MatrixCL.kernel_cache[kernel_name];\n        if (!kernel) {\n          kernel = $CL.createKernel([\n            '#define SRC_TYPE ' + ctypes[val_mat._klass],\n            '#define DST_TYPE ' + ctypes[this._klass],\n            '#define INDEX_TYPE ' + ctypes[index_mat._klass],\n            '#define TYPE_CAST(x) ' + MatrixCL.get_cast_str(this._klass, val_mat._klass),\n            '__kernel void kernel_func(__global DST_TYPE *dst, __global SRC_TYPE *src, __global INDEX_TYPE *index, uint index_length) {',\n            '  uint i = get_global_id(0);',\n            '  if (i >= index_length) { return; }',\n            '  dst[(uint)index[i]-1] = TYPE_CAST(src[i]);',\n            '}'\n          ].join('\\n'));\n          MatrixCL.kernel_cache[kernel_name] = kernel;\n        }\n        if (index_mat._numel > 0) {\n          $CL.executeKernel(kernel, [\n            { access: WebCL.MEM_WRITE_ONLY, datum: this },\n            { access: WebCL.MEM_READ_ONLY, datum: val_mat },\n            { access: WebCL.MEM_READ_ONLY, datum: index_mat },\n            { datum: index_mat._numel, type: WebCL.type.UINT }\n          ], index_mat._numel);\n        }\n      } else {\n        var kernel_name = 'set_matrix_single_scalar_' + this._klass + '_' + index_mat._klass;\n        var kernel = MatrixCL.kernel_cache[kernel_name];\n        if (!kernel) {\n          kernel = $CL.createKernel([\n            '#define DST_TYPE ' + ctypes[this._klass],\n            '#define INDEX_TYPE ' + ctypes[index_mat._klass],\n            '__kernel void kernel_func(__global DST_TYPE *dst, DST_TYPE src, __global INDEX_TYPE *index, uint index_length) {',\n            '  uint i = get_global_id(0);',\n            '  if (i >= index_length) { return; }',\n            '  dst[(uint)index[i]-1] = src;',\n            '}'\n          ].join('\\n'));\n          MatrixCL.kernel_cache[kernel_name] = kernel;\n        }\n        var scalar_val = MatrixCL.cast_scalar_val(<number>val, this._klass);\n        if (index_mat._numel > 0) {\n          $CL.executeKernel(kernel, [\n            { access: WebCL.MEM_WRITE_ONLY, datum: this },\n            { datum: scalar_val, type: webcltypes[this._klass] },\n            { access: WebCL.MEM_READ_ONLY, datum: index_mat },\n            { datum: index_mat._numel, type: WebCL.type.UINT }\n          ], index_mat._numel);\n        }\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      if (destruct_index_mat) {\n        index_mat.destruct();\n      }\n    }\n\n  }\n\n\n  set_matrix_nd(val: number | Matrix, inds: (number | Colon | Matrix)[]): void {\n    var inds_ndim = inds.length;\n    var destruct_targets: Matrix[] = [];\n    try {\n      // replace logical matrix with vector\n      for (var i = 0; i < inds_ndim; i++) {\n        var ind = inds[i];\n        if (ind instanceof Matrix) {\n          if (ind._klass == 'logical') {\n            var idxarray = ind._find();\n            inds[i] = idxarray\n            destruct_targets.push(idxarray);\n          }\n        }\n      }\n\n      var virtual_input_shape: number[] = [];\n      if (this._ndims <= inds_ndim) {\n        // pad with 1\n        virtual_input_shape = this._size.concat();\n        while (virtual_input_shape.length < inds_ndim) {\n          virtual_input_shape.push(1);\n        }\n      } else {\n        // last dimension is like linear index\n        let cur_prod = 1;\n        for (let dim = 0; dim < inds_ndim - 1; dim++) {\n          virtual_input_shape.push(this._size[dim]);\n          cur_prod *= this._size[dim];\n        }\n        virtual_input_shape.push(this._numel / cur_prod);\n      }\n      var virtual_input_stride: number[] = [];\n      var stride_tmp = 1;\n      for (var dim = 0; dim < inds_ndim; dim++) {\n        virtual_input_stride.push(stride_tmp);\n        stride_tmp *= virtual_input_shape[dim];\n      }\n\n      var kernel_args = [];\n      var kernel_type_names = [];\n      var dst_shape = [];\n      var dst_stride = [];//not use dst._strides because tailing 1 dimension is omitted\n      var dst_stride_tmp = 1;\n      var squeezed_dst_shape = [];\n      for (var dim = 0; dim < inds_ndim; dim++) {\n        var iter_and_length = MatrixCL._get_ind_iterator_cl(inds[dim], virtual_input_shape[dim]);\n        if (iter_and_length.to_destruct) {\n          destruct_targets.push(iter_and_length.to_destruct);\n        }\n        kernel_args.push(iter_and_length.kernel_arg);\n        kernel_type_names.push(iter_and_length.typename);\n        dst_shape.push(iter_and_length.length);\n        if (iter_and_length.length != 1) {\n          squeezed_dst_shape.push(iter_and_length.length);\n        }\n        dst_stride.push(dst_stride_tmp);\n        dst_stride_tmp *= iter_and_length.length;\n      }\n      var dst_numel = dst_stride_tmp;\n\n      var val_is_matrix = false;\n      if (val instanceof Matrix) {\n        if ((<Matrix>val)._numel == 1) {\n          //1x1 mat: treat as scalar\n          val = (<Matrix>val).get();\n        } else {\n          val_is_matrix = true;\n          if (!(val instanceof MatrixCL)) {\n            // cpu matrix\n            val = MatrixCL._fromnativemat(<Matrix>val);\n            destruct_targets.push(<Matrix>val);\n          }\n        }\n      }\n\n      if (val_is_matrix) {\n        // check shape\n        // squeezed_dst_shape is 1-d, number of element must match\n        // otherwise, squeezed shape of val must match\n        var val_numel = (<Matrix>val)._numel;\n\n        var raise_error = false;\n        if (squeezed_dst_shape.length == 0) {\n          // set of scalar\n          if (val_numel != 1) {\n            raise_error = true;\n          }\n        } else if (squeezed_dst_shape.length == 1) {\n          if (val_numel != squeezed_dst_shape[0]) {\n            raise_error = true;\n          }\n        } else {\n          var val_shape = (<Matrix>val)._size;\n          var squeezed_val_shape = val_shape.filter((v) => v != 1);\n          if (!squeezed_val_shape.every((v, i) => v == squeezed_dst_shape[i])) {\n            raise_error = true;\n          }\n        }\n\n        if (raise_error) {\n          throw new Error('The shape of matrix does not fit');\n        }\n      }\n\n      var kernel_name = 'set_matrix_nd_' + this._klass + '_' + val_is_matrix + '_' + inds_ndim + '_' + kernel_type_names.join(',');\n      var kernel = MatrixCL.kernel_cache[kernel_name];\n      if (!kernel) {\n        var kernel_index_args_str = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_index_args_str += ',' + kernel_type_names[dim] + ' ind' + dim;//variable ind0, ind1, ...\n        }\n\n        var kernel_add_dim = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_add_dim += 'ADD_IND(' + dim + ');';\n        }\n\n        var kernel_get_ind_func = '';\n        for (var dim = 0; dim < inds_ndim; dim++) {\n          kernel_get_ind_func += 'int get_ind' + dim;\n          var kernel_type_name = kernel_type_names[dim];\n          switch (kernel_type_name) {\n            case 'int':\n              kernel_get_ind_func += '(int indexer, int offset, int dim_size) {return indexer;}';\n              break;\n            case 'int4':\n              kernel_get_ind_func += '(int4 indexer, int offset, int dim_size) {return indexer.x + indexer.y * offset;}';\n              break;\n            default:\n              kernel_get_ind_func += '(' + kernel_type_name + ' indexer, int offset, int dim_size) {int val = (int)indexer[offset]; if (val < 0) { return val + dim_size + 1; } else { return val; }}';\n              break;\n          }\n          kernel_get_ind_func += '\\n';\n        }\n\n        var kernel_str = [\n          '#define DIMS ' + inds_ndim,\n          '#define SRC_TYPE ' + ctypes[this._klass],\n          '#define DST_TYPE ' + ctypes[val_is_matrix ? (<Matrix>val)._klass : this._klass],\n          '#define TYPE_CAST(x) ' + MatrixCL.get_cast_str(this._klass, val_is_matrix ? (<Matrix>val)._klass : this._klass),\n          kernel_get_ind_func,\n          '#define ADD_IND(dim) {dst_coord = (i / dst_stride[dim]) % dst_shape[dim]; src_coord = (get_ind ## dim(ind ## dim, dst_coord, src_shape[dim])) - 1; src_linear_index += src_coord * src_stride[dim];}',\n          '__kernel void kernel_func(',\n          val_is_matrix ? '__global const DST_TYPE *dst' : 'DST_TYPE dst',\n          ', __global SRC_TYPE *src, __global const int *size_strides, uint output_length',\n          kernel_index_args_str,\n          ') {',\n          '  uint i = get_global_id(0);',\n          '  if (i >= output_length) { return; }',\n          '  __global const int *src_stride = size_strides, *src_shape = size_strides + DIMS * 1, *dst_stride = size_strides + DIMS * 2, *dst_shape = size_strides + DIMS * 3;',\n          '  int dst_coord, src_coord;',\n          '  int src_linear_index = 0;',\n          kernel_add_dim,\n          val_is_matrix ? '  src[src_linear_index] = TYPE_CAST(dst[i]);' : '  src[src_linear_index] = TYPE_CAST(dst);',\n          '}'\n        ].join('\\n');\n        kernel = $CL.createKernel(kernel_str);\n\n        MatrixCL.kernel_cache[kernel_name] = kernel;\n      }\n\n      if (dst_numel > 0) {\n        var size_strides = [];//src_stride/src_shape/dst_stride/dst_shape; dst_shape is last because [1] may be added above\n        size_strides.push(...virtual_input_stride);\n        size_strides.push(...virtual_input_shape);\n        size_strides.push(...dst_stride);\n        size_strides.push(...dst_shape);\n\n        var size_strides_mat = MatrixCL._fromtypedarray(new Int32Array(size_strides), 'int32');\n        destruct_targets.push(size_strides_mat);\n\n        kernel_args.unshift(\n          { access: WebCL.MEM_WRITE_ONLY, datum: this },\n          { access: WebCL.MEM_READ_ONLY, datum: size_strides_mat },\n          { datum: dst_numel, type: WebCL.type.UINT });\n        if (val_is_matrix) {\n          kernel_args.unshift({ access: WebCL.MEM_READ_ONLY, datum: val });\n        } else {\n          kernel_args.unshift({ datum: <number>val, type: webcltypes[this._klass] });\n        }\n        $CL.executeKernel(kernel, kernel_args, dst_numel);\n\n      }\n\n    } finally {\n      for (var i = 0; i < destruct_targets.length; i++) {\n        destruct_targets[i].destruct();\n      }\n    }\n  }\n\n  _find(): MatrixCL {\n    //not paralleled; very slow\n\n    //first, count output size\n    var count_mat = new MatrixCL([1, 2], 'int32');\n    var kernel_name = 'matrix_find_count_' + this._klass;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define SRC_TYPE ' + ctypes[this._klass],\n        '__kernel void kernel_func(__global int *count, __global SRC_TYPE *logical_index, uint numel) {',\n        '  int ctr = 0;',\n        '  int max_i = -1;',\n        '  if (get_global_id(0) > 0) {return;}',\n        '  for (uint i = 0; i < numel; i++) {',\n        '    SRC_TYPE val = logical_index[i];',\n        '    if (val) {',\n        '      ctr++;',\n        '      max_i = i;',\n        '    }',\n        '  }',\n        '  count[0] = ctr;',\n        '  count[1] = max_i;',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    var count_array = new Int32Array(2);//default value 0\n    if (this._numel > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: count_mat },\n        { access: WebCL.MEM_READ_ONLY, datum: this },\n        { datum: this._numel, type: WebCL.type.UINT }\n      ], 1);\n      count_mat.read(count_array);\n    }\n\n    var output_length = count_array[0];\n    var max_i = count_array[1];\n\n    //second, write indices\n    var output = new MatrixCL([output_length, 1], 'int32');\n    var kernel_name = 'matrix_find_write_' + this._klass;\n    var kernel = MatrixCL.kernel_cache[kernel_name];\n    if (!kernel) {\n      kernel = $CL.createKernel([\n        '#define SRC_TYPE ' + ctypes[this._klass],\n        '__kernel void kernel_func(__global int *dst, __global SRC_TYPE *src, uint output_length) {',\n        '  uint i = get_global_id(0);',\n        '  if (i > 0) { return; }',\n        '  int out_idx = 0;',\n        '  int in_idx = 0;',\n        '  while (out_idx < output_length) {',\n        '    if (src[in_idx]) {',\n        '      dst[out_idx++] = in_idx + 1;',\n        '    }',\n        '    in_idx++;',\n        '  }',\n        '}'\n      ].join('\\n'));\n      MatrixCL.kernel_cache[kernel_name] = kernel;\n    }\n\n    if (output_length > 0) {\n      $CL.executeKernel(kernel, [\n        { access: WebCL.MEM_WRITE_ONLY, datum: output },\n        { access: WebCL.MEM_READ_ONLY, datum: this },\n        { datum: output_length, type: WebCL.type.UINT }\n      ], 1);\n    }\n    if (this._size[1] == this._numel) {\n      // row vector\n      output.reshape_inplace(this._size);\n    }\n\n    count_mat.destruct();\n\n    return output;\n  }\n\n}\n\nexport = MatrixCL;\n"]}