{"version":3,"file":"npy.js","sourceRoot":"","sources":["npy.ts"],"names":[],"mappings":"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","sourcesContent":["// (c) 2016 Machine Intelligence Laboratory (The University of Tokyo), MIT License.\n// read/write numpy format matrix file\n\nimport Matrix = require('../matrix');\n\nfunction parse_header(header_data: Uint8Array): { descr_wo_endian: string, fortran_order: boolean, shape: number[], little_endian: boolean } {\n  //{'descr': '<i4', 'fortran_order': False, 'shape': (3, 1), }            \\n\n  var header_str = '';\n  for (var i = 0; i < header_data.length; i++) {\n    var element = header_data[i];\n    header_str += String.fromCharCode(element);\n  }\n\n  var hobj = /^\\{'descr': '(.*)', 'fortran_order': (True|False), 'shape': \\(([0-9, ]+)\\), \\} *\\n$/.exec(header_str);\n  if (hobj == null) {\n    throw Error('Failed to parse header string');\n  }\n\n  var typechars = hobj[1];//\"<i4\"\n  var little_endian = true;\n  switch (typechars.substr(0, 1)) {\n    case \"<\":\n    case \"|\"://not applicable (uint8)\n      little_endian = true;\n      break;\n    case \">\":\n      little_endian = false;\n      break;\n    default:\n      throw Error('Unknown endian');\n  }\n  var descr_wo_endian = typechars.substr(1, 2);\n\n  var fortran_order = hobj[2] == 'True';\n  var shape_str = hobj[3].split(',');\n  var shape: number[];\n  if (shape_str[1] == '') {\n    //1-d array (3,) to column vector (3,1)\n    shape = [Number(shape_str[0]), 1];\n  } else {\n    shape = shape_str.map((v) => Number(v.trim()));\n  }\n\n  return { descr_wo_endian: descr_wo_endian, fortran_order: fortran_order, shape: shape, little_endian: little_endian };\n}\n\nfunction is_little_endian(): boolean {\n  /**\n   * Check if this machine is little endian\n   */\n  var raw = new Uint8Array([0x1, 0x2, 0x3, 0x4]);\n  var view = new Uint32Array(raw.buffer);\n  if (view[0] == 0x01020304) {\n    //big endian\n    return false;\n  } else {\n    return true;\n  }\n}\n\nvar mat_klass_map = {\n  'b1': 'logical',\n  'u1': 'uint8',\n  'i4': 'int32',\n  'f4': 'single',\n  'f8': 'single'\n};\nvar view_accessor_map = {\n  'b1': DataView.prototype.getUint8,\n  'u1': DataView.prototype.getUint8,\n  'i4': DataView.prototype.getInt32,\n  'f4': DataView.prototype.getFloat32,\n  'f8': DataView.prototype.getFloat64\n};\nvar view_bytestep_map = { 'b1': 1, 'u1': 1, 'i4': 4, 'f4': 4, 'f8': 8 };\n\nexport function npyread(data: ArrayBuffer | Uint8Array): Matrix {\n  //for node: npyread(fs.readFileSync())\n  var byteOffset = 0;\n  if (ArrayBuffer.isView(data)) {\n    //data is Uint8Array\n    byteOffset = (<Uint8Array>data).byteOffset;\n    data = (<Uint8Array>data).buffer;\n  }\n\n  var header_view = new Uint8Array(data, byteOffset);\n  //check magic number\n  var expect_header = [0x93, 0x4e, 0x55, 0x4d, 0x50, 0x59, 0x01, 0x00];//only format 1 supported\n  for (var i = 0; i < expect_header.length; i++) {\n    if (header_view[i] != expect_header[i]) {\n      throw Error('Incompatible format header');\n    }\n  }\n  var header_len = header_view[8] + header_view[9] * 256;//16bit little endian\n  var data_type = parse_header(header_view.slice(10, 10 + header_len));\n  var mat_klass = mat_klass_map[data_type.descr_wo_endian];\n  if (mat_klass == null) {\n    throw Error('Unsupported data type');\n  }\n  var data_view = new DataView(data, byteOffset + 10 + header_len);\n  //b1 seems to have only 0/1, so no conversion needed\n  var mat = new Matrix(data_type.shape, mat_klass);\n  var mat_data = mat.getdataref();\n  var view_accessor = view_accessor_map[data_type.descr_wo_endian];\n  var view_bytestep = view_bytestep_map[data_type.descr_wo_endian];\n  var numel = mat._numel;\n  var view_little_endian = data_type.little_endian;\n  if (data_type.fortran_order) {\n    // sequentially copy\n    for (var i = 0; i < numel; i++) {\n      var val = view_accessor.call(data_view, view_bytestep * i, view_little_endian);\n      mat_data[i] = val;\n    }\n  } else {\n    //change order from c-order to fortran-order\n    /*\n    Size of matrix: (I, J, K)\n    c-order strides: (J*K, K, 1)\n    f-order strides: (1, I, I*J)\n    when linear index in c-order is x:\n    matrix index: (x / (J*K) % I * 1, x / K % J * I, x / 1 % K * I * J)\n    that is: x / cstride[i] % size[i] * fstride[i] (i = 0,1,2)\n    */\n    var size = mat._size;\n    var cstride = [];\n    var fstride = [];\n    var last_cstride = 1;\n    var last_fstride = 1;\n    for (var dim = 0; dim < size.length; dim++) {\n      cstride.unshift(last_cstride);\n      fstride.push(last_fstride);\n      last_cstride *= size[size.length - 1 - dim];\n      last_fstride *= size[dim];\n    }\n    for (var i = 0; i < numel; i++) {\n      var val = view_accessor.call(data_view, view_bytestep * i, view_little_endian);\n      var fidx = 0;\n      for (var dim = 0; dim < size.length; dim++) {\n        fidx += Math.floor(i / cstride[dim]) % size[dim] * fstride[dim];\n      }\n      mat_data[fidx] = val;\n    }\n\n  }\n\n  return mat;\n}\n\nvar save_klass_map = {'logical': 'b1', 'uint8': 'u1', 'int32': 'i4', 'single': 'f4'};\nvar header_padding = '';\nexport function npysave(A: Matrix): ArrayBuffer {\n\n  var klass = A._klass;\n  var endian_char;\n  switch (klass) {\n    case 'logical':\n    case 'uint8':\n      endian_char = '|';//not applicable\n      break;  \n    default:\n      endian_char = is_little_endian() ? '<' : '>';\n      break;\n  }\n  var header_str = \"{'descr': '\"+endian_char + save_klass_map[klass] + \n  \"', 'fortran_order': True, 'shape': (\" + A._size.join(', ') + \"), }\";\n  //pad header_str to be (multiple of 16) - (magic 10 + last \\n)\n  var pad_len = 16 - (header_str.length + 11) % 16;\n  header_str += '                '.substr(0, pad_len) + '\\n';\n  var header_len = header_str.length;\n  var header_total_len = header_len + 10;//header with magic number\n  var dst_size = A._numel * A._data_ctor.BYTES_PER_ELEMENT + header_total_len;\n  var dst = new ArrayBuffer(dst_size);\n  var dst_byte_offset = 0;\n  var header_dst_view = new Uint8Array(dst, dst_byte_offset, header_total_len);\n  var const_header = [0x93, 0x4e, 0x55, 0x4d, 0x50, 0x59, 0x01, 0x00];\n  for (var i = 0; i < const_header.length; i++) {\n    header_dst_view[i] = const_header[i];\n  }\n  header_dst_view[8] = header_len % 256;\n  header_dst_view[9] = Math.floor(header_len / 256);\n  for (var i = 0; i < header_len; i++) {\n    header_dst_view[10+i] = header_str.charCodeAt(i);\n  }\n\n  var body_dst_view = new A._data_ctor(dst, dst_byte_offset + header_total_len, A._numel);\n  body_dst_view.set(A.getdataref());\n  return dst;\n}\n"]}